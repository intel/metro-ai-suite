[
    {
        "id": "2720733497fe05f3",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": ""
    },
    {
        "id": "6f1d3aa6fc4865cc",
        "type": "subflow",
        "name": "Bounding Box Annotator",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 80,
                "y": 180,
                "wires": [
                    {
                        "id": "df99985d1f994959"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 1480,
                "y": 620,
                "wires": [
                    {
                        "id": "b0dac872bf034754",
                        "port": 0
                    },
                    {
                        "id": "96668e7ad6a75e0d",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "1279585c9501834e",
        "type": "mqtt-broker",
        "name": "",
        "broker": "10.3.233.160",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "56f377808d863d71",
        "type": "ui_tab",
        "name": "Home",
        "icon": "dashboard",
        "disabled": false,
        "hidden": false
    },
    {
        "id": "4b3e41d9e35eaa2a",
        "type": "ui_base",
        "theme": {
            "name": "theme-light",
            "lightTheme": {
                "default": "#0094CE",
                "baseColor": "#0094CE",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif",
                "edited": true,
                "reset": false
            },
            "darkTheme": {
                "default": "#097479",
                "baseColor": "#097479",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif",
                "edited": false
            },
            "customTheme": {
                "name": "Untitled Theme 1",
                "default": "#4B7930",
                "baseColor": "#4B7930",
                "baseFont": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"
            },
            "themeState": {
                "base-color": {
                    "default": "#0094CE",
                    "value": "#0094CE",
                    "edited": false
                },
                "page-titlebar-backgroundColor": {
                    "value": "#0094CE",
                    "edited": false
                },
                "page-backgroundColor": {
                    "value": "#fafafa",
                    "edited": false
                },
                "page-sidebar-backgroundColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "group-textColor": {
                    "value": "#1bbfff",
                    "edited": false
                },
                "group-borderColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "group-backgroundColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "widget-textColor": {
                    "value": "#111111",
                    "edited": false
                },
                "widget-backgroundColor": {
                    "value": "#0094ce",
                    "edited": false
                },
                "widget-borderColor": {
                    "value": "#ffffff",
                    "edited": false
                },
                "base-font": {
                    "value": "-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"
                }
            },
            "angularTheme": {
                "primary": "indigo",
                "accents": "blue",
                "warn": "red",
                "background": "grey",
                "palette": "light"
            }
        },
        "site": {
            "name": "Node-RED Dashboard",
            "hideToolbar": "false",
            "allowSwipe": "false",
            "lockMenu": "false",
            "allowTempTheme": "true",
            "dateFormat": "DD/MM/YYYY",
            "sizes": {
                "sx": 48,
                "sy": 48,
                "gx": 6,
                "gy": 6,
                "cx": 6,
                "cy": 6,
                "px": 0,
                "py": 0
            }
        }
    },
    {
        "id": "64cdbc752e72aa52",
        "type": "ui_group",
        "name": "BBox Annotator",
        "tab": "56f377808d863d71",
        "order": 1,
        "disp": true,
        "width": "26",
        "collapse": false,
        "className": ""
    },
    {
        "id": "df99985d1f994959",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "extract frame from video source",
        "func": "flow.set(\"$parent.user_configuration\", msg.payload);\nflow.set(\"$parent.user_configuration_json_path\", \"/data/public/user_configuration/\" + msg.payload + \".json\");\nflow.set(\"$parent.user_configuration_target_json_path\", \"/data/public/user_configuration/target.json\");\nflow.set(\"$parent.user_configuration_image_path\", \"/data/public/images/\" + msg.payload + \".jpg\");\nflow.set(\"$parent.user_configuration_target_image_path\", \"/data/public/images/target.jpg\");\nmsg.payload = \"ffmpeg -y -i http://10.3.233.160:1880/videos/\" + msg.payload + \".mp4 -ss 00:00:01 -vframes 1 /data/public/images/\" + msg.payload + \".jpg\";\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 250,
        "y": 180,
        "wires": [
            [
                "9c29ce07761393c3"
            ]
        ]
    },
    {
        "id": "9c29ce07761393c3",
        "type": "exec",
        "z": "6f1d3aa6fc4865cc",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 450,
        "y": 180,
        "wires": [
            [
                "816c330835a613c7"
            ],
            [],
            []
        ]
    },
    {
        "id": "b9786d7c71690c77",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "copy configuration file to target path",
        "func": "var target_json_path = flow.get(\"$parent.user_configuration_target_json_path\");\nvar json_path = flow.get(\"$parent.user_configuration_json_path\");\nmsg.payload = \"cp \" + json_path + \" \" + target_json_path;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1460,
        "y": 180,
        "wires": [
            [
                "3a35f9c6c8521b1a"
            ]
        ]
    },
    {
        "id": "3a35f9c6c8521b1a",
        "type": "exec",
        "z": "6f1d3aa6fc4865cc",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1670,
        "y": 180,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "345bc96f5f851ecb",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "create new configuration file",
        "func": "msg.payload = { \"bboxes\": {} };\nmsg.filename = flow.get('$parent.user_configuration_json_path');\nreturn msg;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 280,
        "wires": [
            [
                "eb824d410951906f"
            ]
        ]
    },
    {
        "id": "eb824d410951906f",
        "type": "file",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 1220,
        "y": 280,
        "wires": [
            [
                "b9786d7c71690c77"
            ]
        ]
    },
    {
        "id": "816c330835a613c7",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "copy image to target path",
        "func": "var target_image_path = flow.get(\"$parent.user_configuration_target_image_path\");\nvar image_path = flow.get(\"$parent.user_configuration_image_path\");\nmsg.payload = \"cp \" + image_path + \" \" + target_image_path;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 180,
        "wires": [
            [
                "f457658937757aa8"
            ]
        ]
    },
    {
        "id": "f457658937757aa8",
        "type": "exec",
        "z": "6f1d3aa6fc4865cc",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 810,
        "y": 180,
        "wires": [
            [
                "19cb7eb1ba17a59f"
            ],
            [],
            []
        ]
    },
    {
        "id": "aa47f138c69f2744",
        "type": "file in",
        "z": "6f1d3aa6fc4865cc",
        "name": "READ JSON",
        "filename": "filename",
        "filenameType": "msg",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 1230,
        "y": 180,
        "wires": [
            [
                "b9786d7c71690c77"
            ]
        ]
    },
    {
        "id": "19cb7eb1ba17a59f",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "check if configuration file exists",
        "func": "msg.filename = flow.get('$parent.user_configuration_json_path');\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1010,
        "y": 180,
        "wires": [
            [
                "aa47f138c69f2744"
            ]
        ]
    },
    {
        "id": "213a470553e48789",
        "type": "catch",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "scope": [
            "aa47f138c69f2744"
        ],
        "uncaught": false,
        "x": 810,
        "y": 280,
        "wires": [
            [
                "345bc96f5f851ecb"
            ]
        ]
    },
    {
        "id": "0e157a7ac6b4c0f6",
        "type": "ui_template",
        "z": "6f1d3aa6fc4865cc",
        "group": "64cdbc752e72aa52",
        "name": "",
        "order": 1,
        "width": "0",
        "height": "0",
        "format": "<div style=\"text-align: left;\">\n\t<canvas id=\"drawingCanvas\" width=\"1280\" height=\"720\" style=\"border:1px solid #000;\"></canvas>\n\t<div style=\"position: relative; z-index: 1;\">\n\t</div>\n\t<button onclick=\"addBbox()\">New Bbox</button>\n\t<button onclick=\"removeBbox()\">Remove Bbox</button>\n\t<button onclick=\"resetBbox()\">Reset Bbox</button>\n\t<button onclick=\"clearBbox()\">Clear Bbox</button>\n\t<button onclick=\"updateBbox()\">Save Bbox</button>\n\t<button onclick=\"storeInput()\">Click to Input Text</button>\n\t<input type=\"text\" id=\"userInput\" style=\"display: none;\" placeholder=\"Type something...\">\n\t<p id=\"displayText\"></p>\n</div>\n\n<script>\n\tlet targetBBoxData;\n\tlet handleSize = 10;\n\tlet drag = false;\n\tlet resize = [];\n\tlet bboxList = [];\n\tlet offsetX = [];\n\tlet offsetY = [];\n\tlet currentBboxName = \"not-set\";\n\tlet newBboxName = \"not-set\";\n\t\n\tconst canvas = document.getElementById(\"drawingCanvas\");\n\tconst ctx = canvas.getContext(\"2d\");\n\n\tconst new_img = new Image();\n\tnew_img.src = \"/images/target.jpg\"\n\tnew_img.onload = function() {\n\t  ctx.drawImage(new_img, 0, 0, canvas.width, canvas.height);\n\t  drawBBoxes(targetBBoxData.bboxes);\n\t};\n\t\n\tresetBbox();\n\t\n\tfunction drawBBoxes(bboxes) {\n\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\tctx.drawImage(new_img, 0, 0, canvas.width, canvas.height);\n\t\t\n\t\tObject.entries(bboxes).forEach(([bbox_name, bbox]) => {\n\t\t\tdrawHandles(bbox_name, bbox);\n\t\t})\n\t}\n  \n\tfunction drawHandles(bbox_name, bbox) {\n\t\tctx.strokeStyle = 'orange';\n\t\tctx.lineWidth = 2;\n\t\tctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);  \n\t\t\n\t\tctx.fillStyle = 'red';\n\t\tctx.fillRect(bbox.x - handleSize / 2, bbox.y - handleSize / 2, handleSize, handleSize);\n\t\tctx.fillRect(bbox.x + bbox.width - handleSize / 2, bbox.y - handleSize / 2, handleSize, handleSize);\n\t\tctx.fillRect(bbox.x - handleSize / 2, bbox.y + bbox.height - handleSize / 2, handleSize, handleSize);\n\t\tctx.fillRect(bbox.x + bbox.width - handleSize / 2, bbox.y + bbox.height - handleSize / 2, handleSize, handleSize);\n\t\tctx.fillStyle = 'yellow';\n\t\tctx.font = \"24px Arial\";\n\t\tctx.textAlign = \"center\";\n\t\tctx.fillText(bbox_name, bbox.x, bbox.y - handleSize);\n\t}\n  \n\tcanvas.addEventListener('mousedown', (e) => {\n\t\tlet mousePos = getMousePos(e, canvas);\n\t\tbboxList = [];\n\t\toffsetX = [];\n\t\toffsetY = [];\n\t\tresize = [];\n\t\tObject.entries(targetBBoxData.bboxes).reverse().forEach(([bbox_name, bbox]) => {\n\t\t\tif (isOnHandle(mousePos, bbox, 'top-left')) {\n\t\t\t\tcurrentBboxName = bbox_name;\n\t\t\t\taddResizeIfNotExists(resize, \"top-left\")\n\t\t\t\taddBoxIfNotExists(bboxList, bbox);\n\t\t\t}\n\t\t\telse if (isOnHandle(mousePos, bbox, 'top-right')) {\n\t\t\t\tcurrentBboxName = bbox_name;\n\t\t\t\taddResizeIfNotExists(resize, \"top-right\")\n\t\t\t\taddBoxIfNotExists(bboxList, bbox);\n\t\t\t}\n\t\t\telse if (isOnHandle(mousePos, bbox, 'bottom-left')) {\n\t\t\t\tcurrentBboxName = bbox_name;\n\t\t\t\taddResizeIfNotExists(resize, \"bottom-left\")\n\t\t\t\taddBoxIfNotExists(bboxList, bbox);\n\t\t\t}\n\t\t\telse if (isOnHandle(mousePos, bbox, 'bottom-right')) {\n\t\t\t\tcurrentBboxName = bbox_name;\n\t\t\t\taddResizeIfNotExists(resize, \"bottom-right\")\n\t\t\t\taddBoxIfNotExists(bboxList, bbox);\n\t\t\t}\n\t\t})\n\t\t\n\t\tif (resize.length === 0) {\n\t\t\tObject.entries(targetBBoxData.bboxes).reverse().forEach(([bbox_name, bbox]) => {\n\t\t\t\tif (isInsideRect(mousePos, bbox)) {\n\t\t\t\t\tdrag = true;\n\t\t\t\t\tcurrentBboxName = bbox_name;\n\t\t\t\t\taddOffsetIfNotExists(offsetX, offsetY, mousePos.x - bbox.x, mousePos.y - bbox.y);\n\t\t\t\t\taddBoxIfNotExists(bboxList, bbox);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t});\n\n\tcanvas.addEventListener('mousemove', (e) => {\n\t\tlet mousePos = getMousePos(e, canvas);\n\t\tif (drag && bboxList.length > 0) {\n\t\t\tbboxList[0].x = mousePos.x - offsetX[0];\n\t\t\tbboxList[0].y = mousePos.y - offsetY[0];\n\t\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t\t}\n\t\tif (resize.length > 0 && bboxList.length > 0) {\n\t\t\tif (resize[0] === \"top-left\") {\n\t\t\t\tbboxList[0].width += bboxList[0].x - mousePos.x;\n\t\t\t\tbboxList[0].height += bboxList[0].y - mousePos.y;\n\t\t\t\tbboxList[0].x = mousePos.x;\n\t\t\t\tbboxList[0].y = mousePos.y;\n\t\t\t}\n\t\t\tif (resize[0] === \"top-right\") {\n\t\t\t\tbboxList[0].width = mousePos.x - bboxList[0].x;\n\t\t\t\tbboxList[0].height += bboxList[0].y - mousePos.y;\n\t\t\t\tbboxList[0].y = mousePos.y;\n\t\t\t}\n\t\t\tif (resize[0] === \"bottom-left\") {\n\t\t\t\tbboxList[0].width += bboxList[0].x - mousePos.x;\n\t\t\t\tbboxList[0].height = mousePos.y - bboxList[0].y;\n\t\t\t\tbboxList[0].x = mousePos.x;\n\t\t\t}\n\t\t\tif (resize[0] === \"bottom-right\") {\n\t\t\t\tbboxList[0].width = mousePos.x - bboxList[0].x;\n\t\t\t\tbboxList[0].height = mousePos.y - bboxList[0].y;\n\t\t\t}\n\t\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t\t}\n\t});\n\n\tcanvas.addEventListener('mouseup', () => {\n\t\tdrag = false;\n\t\tresize = [];\n\t});\n\n\tfunction getMousePos(evt, canvas) {\n\t\tconst canva_rect = canvas.getBoundingClientRect();\n\t\treturn {\n\t\t\tx: evt.clientX - canva_rect.left,\n\t\t\ty: evt.clientY - canva_rect.top\n\t\t};\n\t}\n\t\n\tfunction addBoxIfNotExists(bboxList, box) {\n\t\tif (!bboxList.includes(box)) {\n\t\t\tbboxList.push(box);\n\t\t}\n\t}\n\n\tfunction addOffsetIfNotExists(offsetX, offsetY, x, y) {\n\t\tif (!offsetX.includes(x)) {\n\t\t\toffsetX.push(x);\n\t\t\toffsetY.push(y);\n\t\t}\n\t}\n\t\n\tfunction addResizeIfNotExists(resize, x) {\n\t\tif (!resize.includes(x)) {\n\t\t\tresize.push(x);\n\t\t}\n\t}\n\n\tfunction isInsideRect(pos, bbox) {\n\t\treturn pos.x > bbox.x && pos.x < bbox.x + bbox.width && pos.y > bbox.y && pos.y < bbox.y + bbox.height;\n\t}\n\n\tfunction isOnHandle(pos, rect, corner) {\n\t\tswitch (corner) {\n\t\t\tcase \"top-left\":\n\t\t\t\treturn pos.x > rect.x - handleSize / 2 && pos.x < rect.x + handleSize / 2\n\t\t\t\t\t&& pos.y > rect.y - handleSize / 2 && pos.y < rect.y + handleSize / 2;\n\t\t\tcase \"top-right\":\n\t\t\t\treturn pos.x > rect.x + rect.width - handleSize / 2 && pos.x < rect.x + rect.width + handleSize / 2\n\t\t\t\t\t&& pos.y > rect.y - handleSize / 2 && pos.y < rect.y + handleSize / 2;\n\t\t\tcase \"bottom-left\":\n\t\t\t\treturn pos.x > rect.x - handleSize / 2 && pos.x < rect.x + handleSize / 2\n\t\t\t\t\t&& pos.y > rect.y + rect.height - handleSize / 2 && pos.y < rect.y + rect.height + handleSize / 2;\n\t\t\tcase \"bottom-right\":\n\t\t\t\treturn pos.x > rect.x + rect.width - handleSize / 2 && pos.x < rect.x + rect.width + handleSize / 2\n\t\t\t\t\t&& pos.y > rect.y + rect.height - handleSize / 2 && pos.y < rect.y + rect.height + handleSize / 2;\n\t\t\tdefault:\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction addBbox() {\n\t\ttargetBBoxData.bboxes[newBboxName] = { x: 30, y: 30, width: 60, height: 60 };\n\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t}\n\t\n\tfunction removeBbox() {\n\t\tdelete targetBBoxData.bboxes[currentBboxName];\n\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t}\n\n\tfunction resetBbox() {\n\t\tfetch('/user_configuration/target.json')\n\t\t.then(response => response.json())\n\t\t.then(data => {\n\t\t\ttargetBBoxData = data;\n\t\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t\t})\n\t\t.catch(error => console.error('Error loading JSON:', error));\n\t}\n\t\n\tfunction clearBbox() {\n\t\ttargetBBoxData = {\"bboxes\":{}};\n\t\tdrawBBoxes(targetBBoxData.bboxes);\n\t}\n\t\n\tfunction updateBbox() {\n\t\tfetch(\"http://10.3.233.160:1880/user_configuration\", { //\n\t\t  method: \"POST\",\n\t\t  headers: {\n\t\t\t\"Content-Type\": \"application/json\"\n\t\t  },\n\t\t  body: JSON.stringify({ targetBBoxData })\n\t\t})\n\t\t.then(response => response.json())\n\t\t.then(data => console.log(\"Data sent to Node-RED:\", data))\n\t\t.catch(error => console.error(\"Error sending data:\", error));\n\t  }\n\t\n\tfunction storeInput() {\n\t\tlet inputField = document.getElementById('userInput');\n\t\tinputField.style.display = 'inline';\n\t\tinputField.focus();\n\n\t\tconst handleEnter = function(event) {\n\t\t\tif (event.key === 'Enter') {\n\t\t\t\tnewBboxName = inputField.value;\n\t\t\t\tinputField.style.display = 'none';\n\t\t\t\tinputField.value = '';\n\t\t\t\tinputField.removeEventListener('keypress', handleEnter); \n\t\t\t}\n\t\t};\n\t\tinputField.addEventListener('keypress', handleEnter);\n\t}\n  \n</script>\n",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 120,
        "y": 420,
        "wires": [
            []
        ]
    },
    {
        "id": "976fdb34c4a8cb9e",
        "type": "comment",
        "z": "6f1d3aa6fc4865cc",
        "name": "html",
        "info": "",
        "x": 110,
        "y": 360,
        "wires": []
    },
    {
        "id": "e2bba08a4a54179d",
        "type": "file",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 680,
        "y": 560,
        "wires": [
            [
                "efc05a799d0eb099"
            ]
        ]
    },
    {
        "id": "b05b1e3d1cc4654a",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "save endpoint data to configuration file",
        "func": "msg.payload = msg.payload[\"targetBBoxData\"];\nmsg.filename = flow.get('$parent.user_configuration_json_path');\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 560,
        "wires": [
            [
                "e2bba08a4a54179d",
                "b0dac872bf034754"
            ]
        ]
    },
    {
        "id": "58424bf333efd3fe",
        "type": "comment",
        "z": "6f1d3aa6fc4865cc",
        "name": "save new parking lot data",
        "info": "",
        "x": 170,
        "y": 500,
        "wires": []
    },
    {
        "id": "efc05a799d0eb099",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "save configuration file to target file",
        "func": "msg.payload = \"cp \" + flow.get(\"$parent.user_configuration_json_path\") + \" \" + flow.get(\"$parent.user_configuration_target_json_path\");\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 560,
        "wires": [
            [
                "b656a7515c144c0e"
            ]
        ]
    },
    {
        "id": "b656a7515c144c0e",
        "type": "exec",
        "z": "6f1d3aa6fc4865cc",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 1110,
        "y": 560,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "b0dac872bf034754",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "pre-processing data for dashboard use cases",
        "func": "let results = {};\nlet payload = msg.payload[\"bboxes\"];\n\nvar canvas_width = 1280;\nvar canvas_height = 720;\nvar video_pipeline_width = flow.get('$parent.video_pipeline_width');\nvar video_pipeline_height = flow.get('$parent.video_pipeline_height');\n\nvar scale_x = video_pipeline_width / canvas_width;\nvar scale_y = video_pipeline_height / canvas_height;\n\nfor (let key in payload) {\n    var xmin = payload[key][\"x\"] * scale_x;\n    var ymin = payload[key][\"y\"] * scale_y;\n    var xmax = (payload[key][\"x\"] + payload[key][\"width\"]) * scale_x;\n    var ymax = (payload[key][\"y\"] + payload[key][\"height\"]) * scale_y;\n    results[key] = {xmin, ymin, xmax, ymax};\n}\n\nmsg.payload = results;\nmsg.bbox_name = flow.get(\"$parent.user_configuration\");\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 620,
        "wires": [
            []
        ]
    },
    {
        "id": "9ba81c2ec580b296",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "list config files",
        "func": "msg.payload = \"ls /data/public/user_configuration\";\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 220,
        "y": 740,
        "wires": [
            [
                "565ee24f2c20c513"
            ]
        ]
    },
    {
        "id": "565ee24f2c20c513",
        "type": "exec",
        "z": "6f1d3aa6fc4865cc",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "",
        "x": 370,
        "y": 740,
        "wires": [
            [
                "308c4663480ec670"
            ],
            [],
            []
        ]
    },
    {
        "id": "f5306da2266ca53e",
        "type": "inject",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 130,
        "y": 660,
        "wires": [
            [
                "9ba81c2ec580b296"
            ]
        ]
    },
    {
        "id": "308c4663480ec670",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "excluding target files",
        "func": "let inputString = msg.payload;\n\nlet substrings = inputString.split(\"\\n\");\nconst stringToRemove = [\"target.json\", \"\"];\n\nsubstrings = substrings.filter(substring =>\n    !stringToRemove.includes(substring)\n);\n\nfor (let i = 0; i < substrings.length; i++) {\n    substrings[i] = \"/data/public/user_configuration/\" + substrings[i]\n}\n\nmsg.payload = substrings;\nmsg.filenames = substrings;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 740,
        "wires": [
            [
                "fdfab09a7c4051bd"
            ]
        ]
    },
    {
        "id": "fdfab09a7c4051bd",
        "type": "split",
        "z": "6f1d3aa6fc4865cc",
        "name": "Split File Paths",
        "splt": "",
        "spltType": "str",
        "arraySplt": "1",
        "arraySpltType": "len",
        "stream": false,
        "addname": "",
        "property": "payload",
        "x": 740,
        "y": 740,
        "wires": [
            [
                "90125a488d1c55ca"
            ]
        ]
    },
    {
        "id": "90125a488d1c55ca",
        "type": "file in",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "filename": "payload",
        "filenameType": "msg",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 900,
        "y": 740,
        "wires": [
            [
                "96668e7ad6a75e0d"
            ]
        ]
    },
    {
        "id": "96668e7ad6a75e0d",
        "type": "function",
        "z": "6f1d3aa6fc4865cc",
        "name": "pre-processing file data for dashboard use cases",
        "func": "msg.payload = JSON.parse(msg.payload);\n\nvar filePath = msg.filename;\nvar fileName = filePath.substring(filePath.lastIndexOf('/') + 1);\nfileName = fileName.substring(0, fileName.lastIndexOf('.'));\n\nlet results = {};\nlet payload = msg.payload[\"bboxes\"];\n\nvar canvas_width = 1280;\nvar canvas_height = 720;\nvar video_pipeline_width = flow.get('$parent.video_pipeline_width');\nvar video_pipeline_height = flow.get('$parent.video_pipeline_height');\n\nvar scale_x = video_pipeline_width / canvas_width;\nvar scale_y = video_pipeline_height / canvas_height;\n\nfor (let key in payload) {\n    var xmin = payload[key][\"x\"] * scale_x;\n    var ymin = payload[key][\"y\"] * scale_y;\n    var xmax = (payload[key][\"x\"] + payload[key][\"width\"]) * scale_x;\n    var ymax = (payload[key][\"y\"] + payload[key][\"height\"]) * scale_y;\n    results[key] = {xmin, ymin, xmax, ymax};\n}\n\nmsg.payload = results;\nmsg.bbox_name = fileName;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1180,
        "y": 740,
        "wires": [
            []
        ]
    },
    {
        "id": "98e20d0688e95a58",
        "type": "http in",
        "z": "6f1d3aa6fc4865cc",
        "name": "",
        "url": "/user_configuration",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 170,
        "y": 560,
        "wires": [
            [
                "b05b1e3d1cc4654a"
            ]
        ]
    },
    {
        "id": "0356ffb2221df2b0",
        "type": "comment",
        "z": "6f1d3aa6fc4865cc",
        "name": "frame extraction",
        "info": "",
        "x": 140,
        "y": 100,
        "wires": []
    },
    {
        "id": "501e241e7811f9b5",
        "type": "comment",
        "z": "2720733497fe05f3",
        "name": "WARNING: please check you have started this container with a volume that is mounted to /data\\n otherwise any flow changes are lost when you redeploy or upgrade the container\\n (e.g. upgrade to a more recent node-red docker image).\\n  If you are using named volumes you can ignore this warning.\\n Double click or see info side panel to learn how to start Node-RED in Docker to save your work",
        "info": "\nTo start docker with a bind mount volume (-v option), for example:\n\n```\ndocker run -it -p 1880:1880 -v /home/user/node_red_data:/data --name mynodered nodered/node-red\n```\n\nwhere `/home/user/node_red_data` is a directory on your host machine where you want to store your flows.\n\nIf you do not do this then you can experiment and redploy flows, but if you restart or upgrade the container the flows will be disconnected and lost. \n\nThey will still exist in a hidden data volume, which can be recovered using standard docker techniques, but that is much more complex than just starting with a named volume as described above.",
        "x": 350,
        "y": 80,
        "wires": []
    },
    {
        "id": "fe53866a18511815",
        "type": "mqtt in",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "object_detection_1",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "1279585c9501834e",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 170,
        "y": 740,
        "wires": [
            [
                "ae0f27230e40fa4c",
                "efc1d3e922603b9f"
            ]
        ]
    },
    {
        "id": "56a313117a53b976",
        "type": "comment",
        "z": "2720733497fe05f3",
        "name": "MQTT client live",
        "info": "",
        "x": 160,
        "y": 680,
        "wires": []
    },
    {
        "id": "65a15c78ceb22e7d",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 170,
        "y": 260,
        "wires": [
            [
                "77e73091c252ef62"
            ]
        ]
    },
    {
        "id": "c44e1f4281d8a475",
        "type": "comment",
        "z": "2720733497fe05f3",
        "name": "Configurations",
        "info": "",
        "x": 150,
        "y": 200,
        "wires": []
    },
    {
        "id": "7676dcb4cb22fa79",
        "type": "mqtt in",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "object_detection_2",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "1279585c9501834e",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 170,
        "y": 860,
        "wires": [
            [
                "e51f07cf291512e1"
            ]
        ]
    },
    {
        "id": "4a526ed8cdd137b4",
        "type": "mqtt in",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "object_detection_3",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "1279585c9501834e",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 170,
        "y": 980,
        "wires": [
            [
                "ce56f3944f7e028b"
            ]
        ]
    },
    {
        "id": "561d2e16c0680082",
        "type": "mqtt in",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "object_detection_4",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "1279585c9501834e",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 170,
        "y": 1100,
        "wires": [
            [
                "7d2038dc82b41a19"
            ]
        ]
    },
    {
        "id": "0d4a5f1c0c678050",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "2",
        "topic": "",
        "payload": "new_video_1",
        "payloadType": "str",
        "x": 170,
        "y": 520,
        "wires": [
            [
                "2ced39b0bc78b88d"
            ]
        ]
    },
    {
        "id": "c3d158425536709b",
        "type": "comment",
        "z": "2720733497fe05f3",
        "name": "user to upload video",
        "info": "",
        "x": 170,
        "y": 340,
        "wires": []
    },
    {
        "id": "86ca4294b7c31131",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "3",
        "topic": "",
        "payload": "new_video_1",
        "payloadType": "str",
        "x": 170,
        "y": 580,
        "wires": [
            [
                "2ced39b0bc78b88d"
            ]
        ]
    },
    {
        "id": "e7396b2af7046a38",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.2",
        "topic": "",
        "payload": "new_video_1",
        "payloadType": "str",
        "x": 180,
        "y": 400,
        "wires": [
            [
                "2ced39b0bc78b88d"
            ]
        ]
    },
    {
        "id": "11ee4d7c0c3d8ffd",
        "type": "inject",
        "z": "2720733497fe05f3",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "1",
        "topic": "",
        "payload": "new_video_1",
        "payloadType": "str",
        "x": 170,
        "y": 460,
        "wires": [
            [
                "2ced39b0bc78b88d"
            ]
        ]
    },
    {
        "id": "10805e96612a105e",
        "type": "switch",
        "z": "2720733497fe05f3",
        "name": "",
        "property": "bbox_name",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "new_video_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "new_video_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "new_video_1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "new_video_1",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 670,
        "y": 400,
        "wires": [
            [
                "512df888e05ac96d"
            ],
            [
                "3580db2b8a22ba22"
            ],
            [
                "71d7e0c7bd218f13"
            ],
            [
                "26ccd35453bbae67"
            ]
        ]
    },
    {
        "id": "71d7e0c7bd218f13",
        "type": "function",
        "z": "2720733497fe05f3",
        "name": "new_video_1",
        "func": "\nif (Object.keys(msg.payload).length > 0) {\n    flow.set('predefined_regions_3', msg.payload);\n}\nelse {\n    flow.set('predefined_regions_3', -1);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 500,
        "wires": [
            []
        ]
    },
    {
        "id": "26ccd35453bbae67",
        "type": "function",
        "z": "2720733497fe05f3",
        "name": "new_video_1",
        "func": "\nif (Object.keys(msg.payload).length > 0) {\n    flow.set('predefined_regions_4', msg.payload);\n}\nelse {\n    flow.set('predefined_regions_4', -1);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 560,
        "wires": [
            []
        ]
    },
    {
        "id": "512df888e05ac96d",
        "type": "function",
        "z": "2720733497fe05f3",
        "name": "new_video_1",
        "func": "\nif (Object.keys(msg.payload).length > 0) {\n    flow.set('predefined_regions_1', msg.payload);\n}\nelse {\n    flow.set('predefined_regions_1', -1);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 380,
        "wires": [
            []
        ]
    },
    {
        "id": "3580db2b8a22ba22",
        "type": "function",
        "z": "2720733497fe05f3",
        "name": "new_video_1",
        "func": "\nif (Object.keys(msg.payload).length > 0) {\n    flow.set('predefined_regions_2', msg.payload);\n}\nelse {\n    flow.set('predefined_regions_2', -1);\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 890,
        "y": 440,
        "wires": [
            []
        ]
    },
    {
        "id": "2ced39b0bc78b88d",
        "type": "subflow:6f1d3aa6fc4865cc",
        "z": "2720733497fe05f3",
        "name": "Bounding Box Annotator",
        "x": 450,
        "y": 400,
        "wires": [
            [
                "10805e96612a105e"
            ]
        ]
    },
    {
        "id": "77e73091c252ef62",
        "type": "configurations",
        "z": "2720733497fe05f3",
        "name": "configurations 1",
        "func": "//Configurations\nlet target_object = [\"car\", \"truck\", \"bus\"];\nlet video_pipeline_width = 3840;\nlet video_pipeline_height = 2160;\nlet object_confidence = 0.3;\nlet ior_threshold = 0.4;\nlet distance_threshold = 260;\nlet object_counter = true; //true;\n\n// loitering\nlet id_history = [];\nlet id_dump_duration = 5;\nlet stop_duration = 5;\nlet stop_distance = 1000;\nlet loiter_check = false;\nlet loiter_id_payload = [];\n\n/***************************/\n//Don't touch section below//\n/***************************/\nflow.set('target_object', target_object);\nflow.set('video_pipeline_width', video_pipeline_width);\nflow.set('video_pipeline_height', video_pipeline_height);\nflow.set('object_confidence', object_confidence);\nflow.set('ior_threshold', ior_threshold);\nflow.set('distance_threshold', distance_threshold);\nflow.set('object_counter', object_counter);\n\n// loitering\nflow.set('id_history', id_history);\nflow.set('id_dump_duration', id_dump_duration);\nflow.set('stop_duration', stop_duration);\nflow.set('stop_distance', stop_distance);\n\n// check switch\nflow.set('loiter_check', loiter_check);\nflow.set('loiter_id_payload', loiter_id_payload);\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 260,
        "wires": [
            []
        ]
    },
    {
        "id": "a37f305ec97bed22",
        "type": "debug",
        "z": "2720733497fe05f3",
        "name": "debug 1",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1100,
        "y": 800,
        "wires": []
    },
    {
        "id": "736d3038190617d8",
        "type": "mqtt out",
        "z": "2720733497fe05f3",
        "name": "",
        "topic": "object_detection_custom_total_1",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "1279585c9501834e",
        "x": 1460,
        "y": 900,
        "wires": []
    },
    {
        "id": "5b7c5c77f12dd746",
        "type": "multi streams",
        "z": "2720733497fe05f3",
        "name": "multi streams 1",
        "func": "var object_detection_list = [\n    flow.get('object_detection_1'),\n    flow.get('object_detection_2'),\n    flow.get('object_detection_3'),\n    flow.get('object_detection_4'),\n    //Add more\n];\n\nvar result = { \"payload\": {} };\nvar region_index = 0;\nvar status = true;\n\nfor (let i = 0; i < object_detection_list.length; i++) {\n    if (!object_detection_list[i])\n    {\n        status = false;\n        break;\n    }\n\n    if (typeof object_detection_list[i].payload == 'string') {\n        object_detection_list[i].payload = JSON.parse(object_detection_list[i].payload)\n    }\n}\n\nif (status == false) {\n    return result;\n}\n\nfor (let i = 0; i < object_detection_list.length; i++) {\n    var keys = Object.keys(object_detection_list[i].payload);\n\n    for (let j = 0; j < keys.length; j++) {\n        if (!result.payload[\"Region \" + (region_index + 1)]) {\n            result.payload[\"Region \" + (region_index + 1)] = {};\n            result.payload[\"Region \" + (region_index + 1)] = object_detection_list[i].payload[keys[j]];\n        }\n        region_index++;\n    }\n}\n\nreturn result;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 900,
        "wires": [
            [
                "a37f305ec97bed22",
                "24121c3bf9a2dc3a"
            ]
        ]
    },
    {
        "id": "ae0f27230e40fa4c",
        "type": "data extraction",
        "z": "2720733497fe05f3",
        "name": "data extraction 1",
        "func": "let payload = msg.payload[\"objects\"];\nlet result = {};\nlet counter = 1;\n\nvar object_confidence = flow.get('object_confidence');\nvar target_object = flow.get('target_object');\n\nvar id_history = flow.get('id_history');\nvar id_dump_duration = flow.get('id_dump_duration');\nvar stop_duration = flow.get('stop_duration');\nvar stop_distance = flow.get('stop_distance');\nvar new_id_history = [];\n\nvar loiter_check = flow.get('loiter_check');\n\nvar date = new Date();\nvar localDate = new Date(date.toLocaleString('en-US', { timeZone: 'Asia/Kuala_Lumpur' }));\n\nvar years = localDate.getFullYear();\nvar months = (localDate.getMonth() + 1).toString().padStart(2, '0');\nvar dates = (localDate.getDate()).toString().padStart(2, '0');\nvar hours = localDate.getHours();\nvar minutes = localDate.getMinutes();\nvar seconds = localDate.getSeconds();\n\nhours = ('0' + hours).slice(-2);\nminutes = ('0' + minutes).slice(-2);\nseconds = ('0' + seconds).slice(-2);\n\nmsg.nodered_timestamp = years + \"/\" + months + \"/\" + dates + \" \" + hours + ':' + minutes + ':' + seconds;\nmsg.object_timestamp = new Date().getTime() / 1000;\n\nfor (let key in payload) {\n    if (payload.hasOwnProperty(key) && payload[key].hasOwnProperty('detection')) {\n        if (!(target_object.length == 1 && target_object[0] == \"\")) {\n            var skip = true;\n            for (let i = 0; i < target_object.length; i++) {\n                if (payload[key]['roi_type'] == target_object[i]) {\n                    skip = false;\n                    break;\n                }\n            }\n            if (skip == true) { continue; }\n        }\n        if (payload[key]['detection']['confidence'] > object_confidence) {\n            var current_object_data = {\"xmin\": payload[key]['x'], \"ymin\": payload[key]['y'], \"xmax\": (payload[key]['x'] + payload[key]['w']), \"ymax\": (payload[key]['y'] + payload[key]['h'])};\n            if (payload[key].hasOwnProperty('type') && payload[key]['type'].hasOwnProperty('label')) {\n                current_object_data[\"type\"] = payload[key]['type']['label'];\n            }\n            if (payload[key].hasOwnProperty('color') && payload[key]['color'].hasOwnProperty('label')) {\n                current_object_data[\"color\"] = payload[key]['color']['label'];\n            }\n            if (payload[key].hasOwnProperty('license_plate') && payload[key]['license_plate'].hasOwnProperty('label')) {\n                current_object_data[\"license_plate\"] = payload[key]['license_plate']['label'];\n            }\n            if (payload[key].hasOwnProperty('id')) {\n                current_object_data[\"id\"] = payload[key]['id'];\n            }\n            if (payload[key].hasOwnProperty('roi_type')) {\n                current_object_data[\"roi_type\"] = payload[key]['roi_type'];\n            }\n            if (loiter_check) {\n                let loiter_possibility = false;\n                let new_id = true;\n                let x_center = payload[key]['x'] + 0.5 * payload[key]['w'];\n                let y_center = payload[key]['y'] + 0.5 * payload[key]['h'];\n                for (let i = 0; i < id_history.length; i++) {\n                    if (id_history[i].id === current_object_data[\"id\"]) {\n                        let within_distance = false;\n                        let temp_distance = Math.sqrt(Math.pow(x_center - id_history[i].centroid[0], 2) + Math.pow(y_center - id_history[i].centroid[1], 2));\n                        if (temp_distance < stop_distance) {\n                            within_distance = true;\n                        }\n                        if (within_distance) {\n                            if ((msg.payload.timestamp / 1000000000) > id_history[i].timestamp + stop_duration) {\n                                loiter_possibility = true;\n                            }\n                            id_history[i] = { \"id\": id_history[i].id, \"timestamp\": id_history[i].timestamp, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": id_history[i].centroid };\n                        } else {\n                            id_history[i] = { \"id\": id_history[i].id, \"timestamp\": msg.payload.timestamp / 1000000000, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": [x_center, y_center] };\n                        }\n                        new_id = false;\n                        break;\n                    }\n                }\n                if (new_id) {\n                    id_history.push({ \"id\": current_object_data[\"id\"], \"timestamp\": msg.payload.timestamp / 1000000000, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": [x_center, y_center] });\n                }\n                current_object_data[\"loiter_possibility\"] = loiter_possibility;\n            }\n            result[`object_${counter++}`] = current_object_data;\n        }\n    }\n}\n\nif (loiter_check) {\n    for (let i = 0; i < id_history.length; i++) {\n        if (msg.payload.timestamp / 1000000000 < id_history[i].last_timestamp + id_dump_duration) {\n            new_id_history.push(id_history[i]);\n        }\n    }\n    flow.set('id_history', new_id_history);\n}\n\nif (Object.keys(result).length > 0) {\n    msg.payload = result;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 740,
        "wires": [
            [
                "5ecf47a0e28ef1cd"
            ]
        ]
    },
    {
        "id": "e51f07cf291512e1",
        "type": "data extraction",
        "z": "2720733497fe05f3",
        "name": "data extraction 2",
        "func": "let payload = msg.payload[\"objects\"];\nlet result = {};\nlet counter = 1;\n\nvar object_confidence = flow.get('object_confidence');\nvar target_object = flow.get('target_object');\n\nvar id_history = flow.get('id_history');\nvar id_dump_duration = flow.get('id_dump_duration');\nvar stop_duration = flow.get('stop_duration');\nvar stop_distance = flow.get('stop_distance');\nvar new_id_history = [];\n\nvar loiter_check = flow.get('loiter_check');\n\nvar date = new Date();\nvar localDate = new Date(date.toLocaleString('en-US', { timeZone: 'Asia/Kuala_Lumpur' }));\n\nvar years = localDate.getFullYear();\nvar months = (localDate.getMonth() + 1).toString().padStart(2, '0');\nvar dates = (localDate.getDate()).toString().padStart(2, '0');\nvar hours = localDate.getHours();\nvar minutes = localDate.getMinutes();\nvar seconds = localDate.getSeconds();\n\nhours = ('0' + hours).slice(-2);\nminutes = ('0' + minutes).slice(-2);\nseconds = ('0' + seconds).slice(-2);\n\nmsg.nodered_timestamp = years + \"/\" + months + \"/\" + dates + \" \" + hours + ':' + minutes + ':' + seconds;\nmsg.object_timestamp = new Date().getTime() / 1000;\n\nfor (let key in payload) {\n    if (payload.hasOwnProperty(key) && payload[key].hasOwnProperty('detection')) {\n        if (!(target_object.length == 1 && target_object[0] == \"\")) {\n            var skip = true;\n            for (let i = 0; i < target_object.length; i++) {\n                if (payload[key]['roi_type'] == target_object[i]) {\n                    skip = false;\n                    break;\n                }\n            }\n            if (skip == true) { continue; }\n        }\n        if (payload[key]['detection']['confidence'] > object_confidence) {\n            var current_object_data = {\"xmin\": payload[key]['x'], \"ymin\": payload[key]['y'], \"xmax\": (payload[key]['x'] + payload[key]['w']), \"ymax\": (payload[key]['y'] + payload[key]['h'])};\n            if (payload[key].hasOwnProperty('type') && payload[key]['type'].hasOwnProperty('label')) {\n                current_object_data[\"type\"] = payload[key]['type']['label'];\n            }\n            if (payload[key].hasOwnProperty('color') && payload[key]['color'].hasOwnProperty('label')) {\n                current_object_data[\"color\"] = payload[key]['color']['label'];\n            }\n            if (payload[key].hasOwnProperty('license_plate') && payload[key]['license_plate'].hasOwnProperty('label')) {\n                current_object_data[\"license_plate\"] = payload[key]['license_plate']['label'];\n            }\n            if (payload[key].hasOwnProperty('id')) {\n                current_object_data[\"id\"] = payload[key]['id'];\n            }\n            if (payload[key].hasOwnProperty('roi_type')) {\n                current_object_data[\"roi_type\"] = payload[key]['roi_type'];\n            }\n            if (loiter_check) {\n                let loiter_possibility = false;\n                let new_id = true;\n                let x_center = payload[key]['x'] + 0.5 * payload[key]['w'];\n                let y_center = payload[key]['y'] + 0.5 * payload[key]['h'];\n                for (let i = 0; i < id_history.length; i++) {\n                    if (id_history[i].id === current_object_data[\"id\"]) {\n                        let within_distance = false;\n                        let temp_distance = Math.sqrt(Math.pow(x_center - id_history[i].centroid[0], 2) + Math.pow(y_center - id_history[i].centroid[1], 2));\n                        if (temp_distance < stop_distance) {\n                            within_distance = true;\n                        }\n                        if (within_distance) {\n                            if ((msg.payload.timestamp / 1000000000) > id_history[i].timestamp + stop_duration) {\n                                loiter_possibility = true;\n                            }\n                            id_history[i] = { \"id\": id_history[i].id, \"timestamp\": id_history[i].timestamp, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": id_history[i].centroid };\n                        } else {\n                            id_history[i] = { \"id\": id_history[i].id, \"timestamp\": msg.payload.timestamp / 1000000000, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": [x_center, y_center] };\n                        }\n                        new_id = false;\n                        break;\n                    }\n                }\n                if (new_id) {\n                    id_history.push({ \"id\": current_object_data[\"id\"], \"timestamp\": msg.payload.timestamp / 1000000000, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": [x_center, y_center] });\n                }\n                current_object_data[\"loiter_possibility\"] = loiter_possibility;\n            }\n            result[`object_${counter++}`] = current_object_data;\n        }\n    }\n}\n\nif (loiter_check) {\n    for (let i = 0; i < id_history.length; i++) {\n        if (msg.payload.timestamp / 1000000000 < id_history[i].last_timestamp + id_dump_duration) {\n            new_id_history.push(id_history[i]);\n        }\n    }\n    flow.set('id_history', new_id_history);\n}\n\nif (Object.keys(result).length > 0) {\n    msg.payload = result;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 860,
        "wires": [
            [
                "86ba013fc40b6975"
            ]
        ]
    },
    {
        "id": "ce56f3944f7e028b",
        "type": "data extraction",
        "z": "2720733497fe05f3",
        "name": "data extraction 3",
        "func": "let payload = msg.payload[\"objects\"];\nlet result = {};\nlet counter = 1;\n\nvar object_confidence = flow.get('object_confidence');\nvar target_object = flow.get('target_object');\n\nvar id_history = flow.get('id_history');\nvar id_dump_duration = flow.get('id_dump_duration');\nvar stop_duration = flow.get('stop_duration');\nvar stop_distance = flow.get('stop_distance');\nvar new_id_history = [];\n\nvar loiter_check = flow.get('loiter_check');\n\nvar date = new Date();\nvar localDate = new Date(date.toLocaleString('en-US', { timeZone: 'Asia/Kuala_Lumpur' }));\n\nvar years = localDate.getFullYear();\nvar months = (localDate.getMonth() + 1).toString().padStart(2, '0');\nvar dates = (localDate.getDate()).toString().padStart(2, '0');\nvar hours = localDate.getHours();\nvar minutes = localDate.getMinutes();\nvar seconds = localDate.getSeconds();\n\nhours = ('0' + hours).slice(-2);\nminutes = ('0' + minutes).slice(-2);\nseconds = ('0' + seconds).slice(-2);\n\nmsg.nodered_timestamp = years + \"/\" + months + \"/\" + dates + \" \" + hours + ':' + minutes + ':' + seconds;\nmsg.object_timestamp = new Date().getTime() / 1000;\n\nfor (let key in payload) {\n    if (payload.hasOwnProperty(key) && payload[key].hasOwnProperty('detection')) {\n        if (!(target_object.length == 1 && target_object[0] == \"\")) {\n            var skip = true;\n            for (let i = 0; i < target_object.length; i++) {\n                if (payload[key]['roi_type'] == target_object[i]) {\n                    skip = false;\n                    break;\n                }\n            }\n            if (skip == true) { continue; }\n        }\n        if (payload[key]['detection']['confidence'] > object_confidence) {\n            var current_object_data = {\"xmin\": payload[key]['x'], \"ymin\": payload[key]['y'], \"xmax\": (payload[key]['x'] + payload[key]['w']), \"ymax\": (payload[key]['y'] + payload[key]['h'])};\n            if (payload[key].hasOwnProperty('type') && payload[key]['type'].hasOwnProperty('label')) {\n                current_object_data[\"type\"] = payload[key]['type']['label'];\n            }\n            if (payload[key].hasOwnProperty('color') && payload[key]['color'].hasOwnProperty('label')) {\n                current_object_data[\"color\"] = payload[key]['color']['label'];\n            }\n            if (payload[key].hasOwnProperty('license_plate') && payload[key]['license_plate'].hasOwnProperty('label')) {\n                current_object_data[\"license_plate\"] = payload[key]['license_plate']['label'];\n            }\n            if (payload[key].hasOwnProperty('id')) {\n                current_object_data[\"id\"] = payload[key]['id'];\n            }\n            if (payload[key].hasOwnProperty('roi_type')) {\n                current_object_data[\"roi_type\"] = payload[key]['roi_type'];\n            }\n            if (loiter_check) {\n                let loiter_possibility = false;\n                let new_id = true;\n                let x_center = payload[key]['x'] + 0.5 * payload[key]['w'];\n                let y_center = payload[key]['y'] + 0.5 * payload[key]['h'];\n                for (let i = 0; i < id_history.length; i++) {\n                    if (id_history[i].id === current_object_data[\"id\"]) {\n                        let within_distance = false;\n                        let temp_distance = Math.sqrt(Math.pow(x_center - id_history[i].centroid[0], 2) + Math.pow(y_center - id_history[i].centroid[1], 2));\n                        if (temp_distance < stop_distance) {\n                            within_distance = true;\n                        }\n                        if (within_distance) {\n                            if ((msg.payload.timestamp / 1000000000) > id_history[i].timestamp + stop_duration) {\n                                loiter_possibility = true;\n                            }\n                            id_history[i] = { \"id\": id_history[i].id, \"timestamp\": id_history[i].timestamp, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": id_history[i].centroid };\n                        } else {\n                            id_history[i] = { \"id\": id_history[i].id, \"timestamp\": msg.payload.timestamp / 1000000000, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": [x_center, y_center] };\n                        }\n                        new_id = false;\n                        break;\n                    }\n                }\n                if (new_id) {\n                    id_history.push({ \"id\": current_object_data[\"id\"], \"timestamp\": msg.payload.timestamp / 1000000000, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": [x_center, y_center] });\n                }\n                current_object_data[\"loiter_possibility\"] = loiter_possibility;\n            }\n            result[`object_${counter++}`] = current_object_data;\n        }\n    }\n}\n\nif (loiter_check) {\n    for (let i = 0; i < id_history.length; i++) {\n        if (msg.payload.timestamp / 1000000000 < id_history[i].last_timestamp + id_dump_duration) {\n            new_id_history.push(id_history[i]);\n        }\n    }\n    flow.set('id_history', new_id_history);\n}\n\nif (Object.keys(result).length > 0) {\n    msg.payload = result;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 980,
        "wires": [
            [
                "84d91c3d0bc4a47b"
            ]
        ]
    },
    {
        "id": "7d2038dc82b41a19",
        "type": "data extraction",
        "z": "2720733497fe05f3",
        "name": "data extraction 4",
        "func": "let payload = msg.payload[\"objects\"];\nlet result = {};\nlet counter = 1;\n\nvar object_confidence = flow.get('object_confidence');\nvar target_object = flow.get('target_object');\n\nvar id_history = flow.get('id_history');\nvar id_dump_duration = flow.get('id_dump_duration');\nvar stop_duration = flow.get('stop_duration');\nvar stop_distance = flow.get('stop_distance');\nvar new_id_history = [];\n\nvar loiter_check = flow.get('loiter_check');\n\nvar date = new Date();\nvar localDate = new Date(date.toLocaleString('en-US', { timeZone: 'Asia/Kuala_Lumpur' }));\n\nvar years = localDate.getFullYear();\nvar months = (localDate.getMonth() + 1).toString().padStart(2, '0');\nvar dates = (localDate.getDate()).toString().padStart(2, '0');\nvar hours = localDate.getHours();\nvar minutes = localDate.getMinutes();\nvar seconds = localDate.getSeconds();\n\nhours = ('0' + hours).slice(-2);\nminutes = ('0' + minutes).slice(-2);\nseconds = ('0' + seconds).slice(-2);\n\nmsg.nodered_timestamp = years + \"/\" + months + \"/\" + dates + \" \" + hours + ':' + minutes + ':' + seconds;\nmsg.object_timestamp = new Date().getTime() / 1000;\n\nfor (let key in payload) {\n    if (payload.hasOwnProperty(key) && payload[key].hasOwnProperty('detection')) {\n        if (!(target_object.length == 1 && target_object[0] == \"\")) {\n            var skip = true;\n            for (let i = 0; i < target_object.length; i++) {\n                if (payload[key]['roi_type'] == target_object[i]) {\n                    skip = false;\n                    break;\n                }\n            }\n            if (skip == true) { continue; }\n        }\n        if (payload[key]['detection']['confidence'] > object_confidence) {\n            var current_object_data = {\"xmin\": payload[key]['x'], \"ymin\": payload[key]['y'], \"xmax\": (payload[key]['x'] + payload[key]['w']), \"ymax\": (payload[key]['y'] + payload[key]['h'])};\n            if (payload[key].hasOwnProperty('type') && payload[key]['type'].hasOwnProperty('label')) {\n                current_object_data[\"type\"] = payload[key]['type']['label'];\n            }\n            if (payload[key].hasOwnProperty('color') && payload[key]['color'].hasOwnProperty('label')) {\n                current_object_data[\"color\"] = payload[key]['color']['label'];\n            }\n            if (payload[key].hasOwnProperty('license_plate') && payload[key]['license_plate'].hasOwnProperty('label')) {\n                current_object_data[\"license_plate\"] = payload[key]['license_plate']['label'];\n            }\n            if (payload[key].hasOwnProperty('id')) {\n                current_object_data[\"id\"] = payload[key]['id'];\n            }\n            if (payload[key].hasOwnProperty('roi_type')) {\n                current_object_data[\"roi_type\"] = payload[key]['roi_type'];\n            }\n            if (loiter_check) {\n                let loiter_possibility = false;\n                let new_id = true;\n                let x_center = payload[key]['x'] + 0.5 * payload[key]['w'];\n                let y_center = payload[key]['y'] + 0.5 * payload[key]['h'];\n                for (let i = 0; i < id_history.length; i++) {\n                    if (id_history[i].id === current_object_data[\"id\"]) {\n                        let within_distance = false;\n                        let temp_distance = Math.sqrt(Math.pow(x_center - id_history[i].centroid[0], 2) + Math.pow(y_center - id_history[i].centroid[1], 2));\n                        if (temp_distance < stop_distance) {\n                            within_distance = true;\n                        }\n                        if (within_distance) {\n                            if ((msg.payload.timestamp / 1000000000) > id_history[i].timestamp + stop_duration) {\n                                loiter_possibility = true;\n                            }\n                            id_history[i] = { \"id\": id_history[i].id, \"timestamp\": id_history[i].timestamp, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": id_history[i].centroid };\n                        } else {\n                            id_history[i] = { \"id\": id_history[i].id, \"timestamp\": msg.payload.timestamp / 1000000000, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": [x_center, y_center] };\n                        }\n                        new_id = false;\n                        break;\n                    }\n                }\n                if (new_id) {\n                    id_history.push({ \"id\": current_object_data[\"id\"], \"timestamp\": msg.payload.timestamp / 1000000000, \"last_timestamp\": msg.payload.timestamp / 1000000000, \"centroid\": [x_center, y_center] });\n                }\n                current_object_data[\"loiter_possibility\"] = loiter_possibility;\n            }\n            result[`object_${counter++}`] = current_object_data;\n        }\n    }\n}\n\nif (loiter_check) {\n    for (let i = 0; i < id_history.length; i++) {\n        if (msg.payload.timestamp / 1000000000 < id_history[i].last_timestamp + id_dump_duration) {\n            new_id_history.push(id_history[i]);\n        }\n    }\n    flow.set('id_history', new_id_history);\n}\n\nif (Object.keys(result).length > 0) {\n    msg.payload = result;\n    return msg;\n}",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 400,
        "y": 1100,
        "wires": [
            [
                "1380acd8df733731"
            ]
        ]
    },
    {
        "id": "5ecf47a0e28ef1cd",
        "type": "euclidean and ior",
        "z": "2720733497fe05f3",
        "name": "euclidean and ior 1",
        "func": "let region_name = 'predefined_regions_1';\nlet detection_name = 'object_detection_1';\nlet previous_data_name = 'previous_data_1';\nlet occupancy_check_duration = 60;\nlet video_id = 1;\nlet region_id = -1; //Recommend to set this only when there is 1 predefined region in the video\n\nvar payload = msg.payload;\nvar previous_data = flow.get(previous_data_name);\n\n// preparing bboxes\nfunction preprocess_bboxes(payload) {\n    function getObjectData(object_data) {\n        var current_object_data = {};\n        if (object_data.hasOwnProperty('type')) {\n            current_object_data[\"type\"] = object_data['type'];\n        }\n        if (object_data.hasOwnProperty('color')) {\n            current_object_data[\"color\"] = object_data['color'];\n        }\n        if (object_data.hasOwnProperty('license_plate')) {\n            current_object_data[\"license_plate\"] = object_data['license_plate'];\n        }\n        if (object_data.hasOwnProperty('id')) {\n            current_object_data[\"id\"] = object_data['id'];\n        }\n        if (object_data.hasOwnProperty('roi_type')) {\n            current_object_data[\"roi_type\"] = object_data['roi_type'];\n        }\n        if (object_data.hasOwnProperty('loiter_possibility')) {\n            if (object_data['loiter_possibility'] == false) {\n                return null\n            }\n        }\n        return current_object_data;\n    }\n    function getObjectBbox(object_data) {\n        return [object_data.xmin, object_data.ymin, object_data.xmax, object_data.ymax];\n    }\n    function getLotBbox(lot_data) {\n        return [lot_data.xmin, lot_data.ymin, lot_data.xmax, lot_data.ymax];\n    }\n\n    var results = {};\n    var objects = [];\n    var objects_extra = [];\n    var lots = [];\n\n    // get all objects bboxes\n    for (let key in payload) {\n        if (payload.hasOwnProperty(key)) {\n            var getObject = getObjectData(payload[key]);\n            if (getObject !== null) {\n                objects_extra.push(\n                    getObject\n                )\n                objects.push(\n                    getObjectBbox(payload[key])\n                );\n            }\n        }\n    }\n\n    // get all lots bboxes\n    var predefined_regions = flow.get(region_name);\n    var keys = Object.keys(predefined_regions);\n\n    for (let i = 0; i < keys.length; i++) {\n        if (predefined_regions.hasOwnProperty(keys[i]) && keys[i] != \"_msgid\") {\n            lots.push(\n                getLotBbox(predefined_regions[keys[i]])\n            );\n        }\n    }\n\n    results[\"objects\"] = objects;\n    results[\"objects_extra\"] = objects_extra;\n    results[\"lots\"] = lots;\n    return results;\n}\n\n// euclidean distance and iou check\nfunction euclidean_iou_function(payload, distance_threshold = 100, IoU_threshold = 0.5, object_counter = false) {\n    function getCentroid(bbox) {\n        var centroid_x = (bbox[0] + bbox[2]) / 2;\n        var centroid_y = (bbox[1] + bbox[3]) / 2;\n        return [centroid_x, centroid_y];\n    }\n    function calculateEuclideanDistance(centroid1, centroid2) {\n        return Math.sqrt((centroid2[0] - centroid1[0]) ** 2 + (centroid2[1] - centroid1[1]) ** 2);\n    }\n    function calculateIoU(bbox1, bbox2) {\n        var xmin1 = bbox1[0], ymin1 = bbox1[1], xmax1 = bbox1[2], ymax1 = bbox1[3];\n        var xmin2 = bbox2[0], ymin2 = bbox2[1], xmax2 = bbox2[2], ymax2 = bbox2[3];\n        var inter_xmin = Math.max(xmin1, xmin2);\n        var inter_ymin = Math.max(ymin1, ymin2);\n        var inter_xmax = Math.min(xmax1, xmax2);\n        var inter_ymax = Math.min(ymax1, ymax2);\n        var inter_width = Math.max(0, inter_xmax - inter_xmin);\n        var inter_height = Math.max(0, inter_ymax - inter_ymin);\n        var inter_area = inter_width * inter_height;\n        var bbox1_area = (xmax1 - xmin1) * (ymax1 - ymin1);\n        var bbox2_area = (xmax2 - xmin2) * (ymax2 - ymin2);\n        var iou = inter_area / (bbox1_area + bbox2_area - inter_area);\n        return iou;\n    }\n    function calculateIoR(bbox1, bbox2) {\n        var xmin1 = bbox1[0], ymin1 = bbox1[1], xmax1 = bbox1[2], ymax1 = bbox1[3];\n        var xmin2 = bbox2[0], ymin2 = bbox2[1], xmax2 = bbox2[2], ymax2 = bbox2[3];\n        var inter_xmin = Math.max(xmin1, xmin2);\n        var inter_ymin = Math.max(ymin1, ymin2);\n        var inter_xmax = Math.min(xmax1, xmax2);\n        var inter_ymax = Math.min(ymax1, ymax2);\n        var inter_width = Math.max(0, inter_xmax - inter_xmin);\n        var inter_height = Math.max(0, inter_ymax - inter_ymin);\n        var inter_area = inter_width * inter_height;\n        var bbox1_area = (xmax1 - xmin1) * (ymax1 - ymin1);\n        var bbox2_area = (xmax2 - xmin2) * (ymax2 - ymin2);\n        var ior = inter_area / (bbox1_area);\n        return ior;\n    }\n    var occupied = [];\n    var current_index = -1;\n    // initialize lots to no object\n    for (let key1 in payload[\"lots\"]) {\n        if (payload[\"lots\"].hasOwnProperty(key1)) {\n            occupied.push({\"occupied\": 0});\n        }\n    }\n    // replicating the \"smart_parking\" algorithm\n    // get object centroids\n    for (let key1 in payload[\"objects\"]) {\n        current_index++;\n        if (payload[\"objects\"].hasOwnProperty(key1)) {\n            var objectCentroid = getCentroid(payload[\"objects\"][key1]);\n            // loop through region and find the best object\n            var potential_region = [];\n            for (let key2 in payload[\"lots\"]) {\n                if (payload[\"lots\"].hasOwnProperty(key2)) {\n                    var regionCentroid = getCentroid(payload[\"lots\"][key2]);\n                    var euclideanDistance = calculateEuclideanDistance(objectCentroid, regionCentroid);\n                    potential_region.push(euclideanDistance);\n                }\n            }\n            // check all lots occupied by the object\n            if (object_counter) {\n                for (let i = 0; i < potential_region.length; i++) {\n                    if (potential_region[i] < distance_threshold) {\n                        var IoR = calculateIoR(payload[\"objects\"][key1], payload[\"lots\"][i]);\n                        if (IoR > IoU_threshold) {\n                            occupied[i][\"occupied\"] += 1;\n                            var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                            var numberData = keyData.length;\n\n                            for (let j = 0; j < numberData; j++) {\n                                if (!occupied[i][\"extra\"]) {\n                                    occupied[i][\"extra\"] = {};\n                                }\n\n                                if (!occupied[i][\"extra\"][keyData[j]]) {\n                                    occupied[i][\"extra\"][keyData[j]] = [];\n                                }\n                                occupied[i][\"extra\"][keyData[j]].push(payload[\"objects_extra\"][current_index][keyData[j]]);\n                            }\n                        }\n                    }\n                }\n            }\n            // get the best lot occupied by the object\n            else {\n                var best_region_index = potential_region.reduce((minIndex, currentValue, currentIndex, array) =>\n                    currentValue < array[minIndex] ? currentIndex : minIndex, 0);\n                if (potential_region[best_region_index] < distance_threshold) {\n                    var IoR = calculateIoR(payload[\"objects\"][key1], payload[\"lots\"][best_region_index]);\n                    if (IoR > IoU_threshold) {\n                        occupied[best_region_index][\"occupied\"] += 1;\n                        var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                        var numberData = keyData.length;\n\n                        for (let i = 0; i < numberData; i++) {\n                            if (!occupied[best_region_index][\"extra\"]) {\n                                occupied[best_region_index][\"extra\"] = {};\n                            }\n\n                            if (!occupied[best_region_index][\"extra\"][keyData[i]]) {\n                                occupied[best_region_index][\"extra\"][keyData[i]] = [];\n                            }\n                            occupied[best_region_index][\"extra\"][keyData[i]].push(payload[\"objects_extra\"][current_index][keyData[i]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return occupied\n}\n\n// turn into correct format\nfunction postprocess_output(occupied) {\n    var results = {};\n\n    for (let i = 0; i < occupied.length; i++) {\n        if (!results[\"Region \" + (i + 1)]) {\n            results[\"Region \" + (i + 1)] = {};\n        }\n\n        results[\"Region \" + (i + 1)][\"video_id\"] = video_id;\n        results[\"Region \" + (i + 1)][\"region_id\"] = (region_id != -1) ? region_id : i + 1;\n\n        if (occupied[i].hasOwnProperty('occupied')) {\n            results[\"Region \" + (i + 1)][\"occupied\"] = occupied[i].occupied;\n        }\n\n        if (occupied[i].hasOwnProperty('extra')) {\n            for (let key in occupied[i].extra) {\n                results[\"Region \" + (i + 1)][key] = occupied[i].extra[key];\n            }\n        }\n\n        results[\"Region \" + (i + 1)][\"actual_entry_time\"] = null;\n        results[\"Region \" + (i + 1)][\"entry_time\"] = null;\n        results[\"Region \" + (i + 1)][\"dwell_time\"] = null;\n        results[\"Region \" + (i + 1)][\"exit_time\"] = null;\n        results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n\n        if (!previous_data) {\n            previous_data = {};\n        }\n\n        if (!previous_data.hasOwnProperty(\"Region \" + (i + 1))) {\n            previous_data[\"Region \" + (i + 1)] = results[\"Region \" + (i + 1)];\n            previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"entry_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"dwell_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"exit_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n        }\n\n        if (results[\"Region \" + (i + 1)][\"occupied\"] > 0) {\n            if (previous_data[\"Region \" + (i + 1)][\"entry_time\"] == null) {\n                results[\"Region \" + (i + 1)][\"actual_entry_time\"] = msg.nodered_timestamp;\n                results[\"Region \" + (i + 1)][\"entry_time\"] = msg.object_timestamp;\n            }\n            else {\n                if (previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] >= occupancy_check_duration) {\n                    results[\"Region \" + (i + 1)][\"dwell_time\"] = \"00:00:00\";\n                    results[\"Region \" + (i + 1)][\"actual_entry_time\"] = msg.nodered_timestamp;\n                    results[\"Region \" + (i + 1)][\"entry_time\"] = msg.object_timestamp;\n                }\n                else {\n                    results[\"Region \" + (i + 1)][\"actual_entry_time\"] = previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"];\n                    results[\"Region \" + (i + 1)][\"entry_time\"] = previous_data[\"Region \" + (i + 1)][\"entry_time\"];\n                }\n                var dwell_timestamp = msg.object_timestamp - results[\"Region \" + (i + 1)][\"entry_time\"];\n\n                var dwell_hours = Math.floor(dwell_timestamp / 3600).toString();\n                dwell_hours = dwell_hours.toString().length == 1 ? dwell_hours.toString().padStart(2, '0') : dwell_hours.toString();\n\n                var dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, '0');\n                var dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, '0');\n\n                results[\"Region \" + (i + 1)][\"dwell_time\"] = dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds;\n                results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n            }\n        }\n        else if (previous_data[\"Region \" + (i + 1)][\"entry_time\"]) {\n            results[\"Region \" + (i + 1)][\"actual_entry_time\"] = previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"];\n            results[\"Region \" + (i + 1)][\"entry_time\"] = previous_data[\"Region \" + (i + 1)][\"entry_time\"];\n            results[\"Region \" + (i + 1)][\"dwell_time\"] = previous_data[\"Region \" + (i + 1)][\"dwell_time\"];\n            results[\"Region \" + (i + 1)][\"occupancy_check\"] = previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] + 1;\n\n            if (previous_data[\"Region \" + (i + 1)][\"exit_time\"]) {\n                results[\"Region \" + (i + 1)][\"exit_time\"] = previous_data[\"Region \" + (i + 1)][\"exit_time\"];\n            }\n            else {\n                results[\"Region \" + (i + 1)][\"exit_time\"] = msg.nodered_timestamp;\n            }\n        }\n    }\n    return results;\n}\n\nfunction main(payload, distance_threshold = 100, IoU_threshold = 0.5, object_counter = false) {\n    var results = preprocess_bboxes(payload);\n    var occupied = euclidean_iou_function(results, distance_threshold, IoU_threshold, object_counter);\n    var out = postprocess_output(occupied);\n    flow.set(previous_data_name, out);\n    return out;\n}\n\n// user-defined parameters\nvar distance_threshold = flow.get('distance_threshold');\nvar ior_threshold = flow.get('ior_threshold');\nvar object_counter = flow.get('object_counter');\n\nmsg.payload = main(payload, distance_threshold, ior_threshold, object_counter);\nflow.set(detection_name, msg);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 740,
        "wires": [
            [
                "5b7c5c77f12dd746"
            ]
        ]
    },
    {
        "id": "86ba013fc40b6975",
        "type": "euclidean and ior",
        "z": "2720733497fe05f3",
        "name": "euclidean and ior 2",
        "func": "let region_name = 'predefined_regions_2';\nlet detection_name = 'object_detection_2';\nlet previous_data_name = 'previous_data_2';\nlet occupancy_check_duration = 60;\nlet video_id = 2;\nlet region_id = -1; //Recommend to set this only when there is 1 predefined region in the video\n\nvar payload = msg.payload;\nvar previous_data = flow.get(previous_data_name);\n\n// preparing bboxes\nfunction preprocess_bboxes(payload) {\n    function getObjectData(object_data) {\n        var current_object_data = {};\n        if (object_data.hasOwnProperty('type')) {\n            current_object_data[\"type\"] = object_data['type'];\n        }\n        if (object_data.hasOwnProperty('color')) {\n            current_object_data[\"color\"] = object_data['color'];\n        }\n        if (object_data.hasOwnProperty('license_plate')) {\n            current_object_data[\"license_plate\"] = object_data['license_plate'];\n        }\n        if (object_data.hasOwnProperty('id')) {\n            current_object_data[\"id\"] = object_data['id'];\n        }\n        if (object_data.hasOwnProperty('roi_type')) {\n            current_object_data[\"roi_type\"] = object_data['roi_type'];\n        }\n        if (object_data.hasOwnProperty('loiter_possibility')) {\n            if (object_data['loiter_possibility'] == false) {\n                return null\n            }\n        }\n        return current_object_data;\n    }\n    function getObjectBbox(object_data) {\n        return [object_data.xmin, object_data.ymin, object_data.xmax, object_data.ymax];\n    }\n    function getLotBbox(lot_data) {\n        return [lot_data.xmin, lot_data.ymin, lot_data.xmax, lot_data.ymax];\n    }\n\n    var results = {};\n    var objects = [];\n    var objects_extra = [];\n    var lots = [];\n\n    // get all objects bboxes\n    for (let key in payload) {\n        if (payload.hasOwnProperty(key)) {\n            var getObject = getObjectData(payload[key]);\n            if (getObject !== null) {\n                objects_extra.push(\n                    getObject\n                )\n                objects.push(\n                    getObjectBbox(payload[key])\n                );\n            }\n        }\n    }\n\n    // get all lots bboxes\n    var predefined_regions = flow.get(region_name);\n    var keys = Object.keys(predefined_regions);\n\n    for (let i = 0; i < keys.length; i++) {\n        if (predefined_regions.hasOwnProperty(keys[i]) && keys[i] != \"_msgid\") {\n            lots.push(\n                getLotBbox(predefined_regions[keys[i]])\n            );\n        }\n    }\n\n    results[\"objects\"] = objects;\n    results[\"objects_extra\"] = objects_extra;\n    results[\"lots\"] = lots;\n    return results;\n}\n\n// euclidean distance and iou check\nfunction euclidean_iou_function(payload, distance_threshold = 100, IoU_threshold = 0.5, object_counter = false) {\n    function getCentroid(bbox) {\n        var centroid_x = (bbox[0] + bbox[2]) / 2;\n        var centroid_y = (bbox[1] + bbox[3]) / 2;\n        return [centroid_x, centroid_y];\n    }\n    function calculateEuclideanDistance(centroid1, centroid2) {\n        return Math.sqrt((centroid2[0] - centroid1[0]) ** 2 + (centroid2[1] - centroid1[1]) ** 2);\n    }\n    function calculateIoU(bbox1, bbox2) {\n        var xmin1 = bbox1[0], ymin1 = bbox1[1], xmax1 = bbox1[2], ymax1 = bbox1[3];\n        var xmin2 = bbox2[0], ymin2 = bbox2[1], xmax2 = bbox2[2], ymax2 = bbox2[3];\n        var inter_xmin = Math.max(xmin1, xmin2);\n        var inter_ymin = Math.max(ymin1, ymin2);\n        var inter_xmax = Math.min(xmax1, xmax2);\n        var inter_ymax = Math.min(ymax1, ymax2);\n        var inter_width = Math.max(0, inter_xmax - inter_xmin);\n        var inter_height = Math.max(0, inter_ymax - inter_ymin);\n        var inter_area = inter_width * inter_height;\n        var bbox1_area = (xmax1 - xmin1) * (ymax1 - ymin1);\n        var bbox2_area = (xmax2 - xmin2) * (ymax2 - ymin2);\n        var iou = inter_area / (bbox1_area + bbox2_area - inter_area);\n        return iou;\n    }\n    function calculateIoR(bbox1, bbox2) {\n        var xmin1 = bbox1[0], ymin1 = bbox1[1], xmax1 = bbox1[2], ymax1 = bbox1[3];\n        var xmin2 = bbox2[0], ymin2 = bbox2[1], xmax2 = bbox2[2], ymax2 = bbox2[3];\n        var inter_xmin = Math.max(xmin1, xmin2);\n        var inter_ymin = Math.max(ymin1, ymin2);\n        var inter_xmax = Math.min(xmax1, xmax2);\n        var inter_ymax = Math.min(ymax1, ymax2);\n        var inter_width = Math.max(0, inter_xmax - inter_xmin);\n        var inter_height = Math.max(0, inter_ymax - inter_ymin);\n        var inter_area = inter_width * inter_height;\n        var bbox1_area = (xmax1 - xmin1) * (ymax1 - ymin1);\n        var bbox2_area = (xmax2 - xmin2) * (ymax2 - ymin2);\n        var ior = inter_area / (bbox1_area);\n        return ior;\n    }\n    var occupied = [];\n    var current_index = -1;\n    // initialize lots to no object\n    for (let key1 in payload[\"lots\"]) {\n        if (payload[\"lots\"].hasOwnProperty(key1)) {\n            occupied.push({\"occupied\": 0});\n        }\n    }\n    // replicating the \"smart_parking\" algorithm\n    // get object centroids\n    for (let key1 in payload[\"objects\"]) {\n        current_index++;\n        if (payload[\"objects\"].hasOwnProperty(key1)) {\n            var objectCentroid = getCentroid(payload[\"objects\"][key1]);\n            // loop through region and find the best object\n            var potential_region = [];\n            for (let key2 in payload[\"lots\"]) {\n                if (payload[\"lots\"].hasOwnProperty(key2)) {\n                    var regionCentroid = getCentroid(payload[\"lots\"][key2]);\n                    var euclideanDistance = calculateEuclideanDistance(objectCentroid, regionCentroid);\n                    potential_region.push(euclideanDistance);\n                }\n            }\n            // check all lots occupied by the object\n            if (object_counter) {\n                for (let i = 0; i < potential_region.length; i++) {\n                    if (potential_region[i] < distance_threshold) {\n                        var IoR = calculateIoR(payload[\"objects\"][key1], payload[\"lots\"][i]);\n                        if (IoR > IoU_threshold) {\n                            occupied[i][\"occupied\"] += 1;\n                            var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                            var numberData = keyData.length;\n\n                            for (let j = 0; j < numberData; j++) {\n                                if (!occupied[i][\"extra\"]) {\n                                    occupied[i][\"extra\"] = {};\n                                }\n\n                                if (!occupied[i][\"extra\"][keyData[j]]) {\n                                    occupied[i][\"extra\"][keyData[j]] = [];\n                                }\n                                occupied[i][\"extra\"][keyData[j]].push(payload[\"objects_extra\"][current_index][keyData[j]]);\n                            }\n                        }\n                    }\n                }\n            }\n            // get the best lot occupied by the object\n            else {\n                var best_region_index = potential_region.reduce((minIndex, currentValue, currentIndex, array) =>\n                    currentValue < array[minIndex] ? currentIndex : minIndex, 0);\n                if (potential_region[best_region_index] < distance_threshold) {\n                    var IoR = calculateIoR(payload[\"objects\"][key1], payload[\"lots\"][best_region_index]);\n                    if (IoR > IoU_threshold) {\n                        occupied[best_region_index][\"occupied\"] += 1;\n                        var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                        var numberData = keyData.length;\n\n                        for (let i = 0; i < numberData; i++) {\n                            if (!occupied[best_region_index][\"extra\"]) {\n                                occupied[best_region_index][\"extra\"] = {};\n                            }\n\n                            if (!occupied[best_region_index][\"extra\"][keyData[i]]) {\n                                occupied[best_region_index][\"extra\"][keyData[i]] = [];\n                            }\n                            occupied[best_region_index][\"extra\"][keyData[i]].push(payload[\"objects_extra\"][current_index][keyData[i]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return occupied\n}\n\n// turn into correct format\nfunction postprocess_output(occupied) {\n    var results = {};\n\n    for (let i = 0; i < occupied.length; i++) {\n        if (!results[\"Region \" + (i + 1)]) {\n            results[\"Region \" + (i + 1)] = {};\n        }\n\n        results[\"Region \" + (i + 1)][\"video_id\"] = video_id;\n        results[\"Region \" + (i + 1)][\"region_id\"] = (region_id != -1) ? region_id : i + 1;\n\n        if (occupied[i].hasOwnProperty('occupied')) {\n            results[\"Region \" + (i + 1)][\"occupied\"] = occupied[i].occupied;\n        }\n\n        if (occupied[i].hasOwnProperty('extra')) {\n            for (let key in occupied[i].extra) {\n                results[\"Region \" + (i + 1)][key] = occupied[i].extra[key];\n            }\n        }\n\n        results[\"Region \" + (i + 1)][\"actual_entry_time\"] = null;\n        results[\"Region \" + (i + 1)][\"entry_time\"] = null;\n        results[\"Region \" + (i + 1)][\"dwell_time\"] = null;\n        results[\"Region \" + (i + 1)][\"exit_time\"] = null;\n        results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n\n        if (!previous_data) {\n            previous_data = {};\n        }\n\n        if (!previous_data.hasOwnProperty(\"Region \" + (i + 1))) {\n            previous_data[\"Region \" + (i + 1)] = results[\"Region \" + (i + 1)];\n            previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"entry_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"dwell_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"exit_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n        }\n\n        if (results[\"Region \" + (i + 1)][\"occupied\"] > 0) {\n            if (previous_data[\"Region \" + (i + 1)][\"entry_time\"] == null) {\n                results[\"Region \" + (i + 1)][\"actual_entry_time\"] = msg.nodered_timestamp;\n                results[\"Region \" + (i + 1)][\"entry_time\"] = msg.object_timestamp;\n            }\n            else {\n                if (previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] >= occupancy_check_duration) {\n                    results[\"Region \" + (i + 1)][\"dwell_time\"] = \"00:00:00\";\n                    results[\"Region \" + (i + 1)][\"actual_entry_time\"] = msg.nodered_timestamp;\n                    results[\"Region \" + (i + 1)][\"entry_time\"] = msg.object_timestamp;\n                }\n                else {\n                    results[\"Region \" + (i + 1)][\"actual_entry_time\"] = previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"];\n                    results[\"Region \" + (i + 1)][\"entry_time\"] = previous_data[\"Region \" + (i + 1)][\"entry_time\"];\n                }\n                var dwell_timestamp = msg.object_timestamp - results[\"Region \" + (i + 1)][\"entry_time\"];\n\n                var dwell_hours = Math.floor(dwell_timestamp / 3600).toString();\n                dwell_hours = dwell_hours.toString().length == 1 ? dwell_hours.toString().padStart(2, '0') : dwell_hours.toString();\n\n                var dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, '0');\n                var dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, '0');\n\n                results[\"Region \" + (i + 1)][\"dwell_time\"] = dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds;\n                results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n            }\n        }\n        else if (previous_data[\"Region \" + (i + 1)][\"entry_time\"]) {\n            results[\"Region \" + (i + 1)][\"actual_entry_time\"] = previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"];\n            results[\"Region \" + (i + 1)][\"entry_time\"] = previous_data[\"Region \" + (i + 1)][\"entry_time\"];\n            results[\"Region \" + (i + 1)][\"dwell_time\"] = previous_data[\"Region \" + (i + 1)][\"dwell_time\"];\n            results[\"Region \" + (i + 1)][\"occupancy_check\"] = previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] + 1;\n\n            if (previous_data[\"Region \" + (i + 1)][\"exit_time\"]) {\n                results[\"Region \" + (i + 1)][\"exit_time\"] = previous_data[\"Region \" + (i + 1)][\"exit_time\"];\n            }\n            else {\n                results[\"Region \" + (i + 1)][\"exit_time\"] = msg.nodered_timestamp;\n            }\n        }\n    }\n    return results;\n}\n\nfunction main(payload, distance_threshold = 100, IoU_threshold = 0.5, object_counter = false) {\n    var results = preprocess_bboxes(payload);\n    var occupied = euclidean_iou_function(results, distance_threshold, IoU_threshold, object_counter);\n    var out = postprocess_output(occupied);\n    flow.set(previous_data_name, out);\n    return out;\n}\n\n// user-defined parameters\nvar distance_threshold = flow.get('distance_threshold');\nvar ior_threshold = flow.get('ior_threshold');\nvar object_counter = flow.get('object_counter');\n\nmsg.payload = main(payload, distance_threshold, ior_threshold, object_counter);\nflow.set(detection_name, msg);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 860,
        "wires": [
            [
                "5b7c5c77f12dd746"
            ]
        ]
    },
    {
        "id": "84d91c3d0bc4a47b",
        "type": "euclidean and ior",
        "z": "2720733497fe05f3",
        "name": "euclidean and ior 3",
        "func": "let region_name = 'predefined_regions_3';\nlet detection_name = 'object_detection_3';\nlet previous_data_name = 'previous_data_3';\nlet occupancy_check_duration = 60;\nlet video_id = 3;\nlet region_id = -1; //Recommend to set this only when there is 1 predefined region in the video\n\nvar payload = msg.payload;\nvar previous_data = flow.get(previous_data_name);\n\n// preparing bboxes\nfunction preprocess_bboxes(payload) {\n    function getObjectData(object_data) {\n        var current_object_data = {};\n        if (object_data.hasOwnProperty('type')) {\n            current_object_data[\"type\"] = object_data['type'];\n        }\n        if (object_data.hasOwnProperty('color')) {\n            current_object_data[\"color\"] = object_data['color'];\n        }\n        if (object_data.hasOwnProperty('license_plate')) {\n            current_object_data[\"license_plate\"] = object_data['license_plate'];\n        }\n        if (object_data.hasOwnProperty('id')) {\n            current_object_data[\"id\"] = object_data['id'];\n        }\n        if (object_data.hasOwnProperty('roi_type')) {\n            current_object_data[\"roi_type\"] = object_data['roi_type'];\n        }\n        if (object_data.hasOwnProperty('loiter_possibility')) {\n            if (object_data['loiter_possibility'] == false) {\n                return null\n            }\n        }\n        return current_object_data;\n    }\n    function getObjectBbox(object_data) {\n        return [object_data.xmin, object_data.ymin, object_data.xmax, object_data.ymax];\n    }\n    function getLotBbox(lot_data) {\n        return [lot_data.xmin, lot_data.ymin, lot_data.xmax, lot_data.ymax];\n    }\n\n    var results = {};\n    var objects = [];\n    var objects_extra = [];\n    var lots = [];\n\n    // get all objects bboxes\n    for (let key in payload) {\n        if (payload.hasOwnProperty(key)) {\n            var getObject = getObjectData(payload[key]);\n            if (getObject !== null) {\n                objects_extra.push(\n                    getObject\n                )\n                objects.push(\n                    getObjectBbox(payload[key])\n                );\n            }\n        }\n    }\n\n    // get all lots bboxes\n    var predefined_regions = flow.get(region_name);\n    var keys = Object.keys(predefined_regions);\n\n    for (let i = 0; i < keys.length; i++) {\n        if (predefined_regions.hasOwnProperty(keys[i]) && keys[i] != \"_msgid\") {\n            lots.push(\n                getLotBbox(predefined_regions[keys[i]])\n            );\n        }\n    }\n\n    results[\"objects\"] = objects;\n    results[\"objects_extra\"] = objects_extra;\n    results[\"lots\"] = lots;\n    return results;\n}\n\n// euclidean distance and iou check\nfunction euclidean_iou_function(payload, distance_threshold = 100, IoU_threshold = 0.5, object_counter = false) {\n    function getCentroid(bbox) {\n        var centroid_x = (bbox[0] + bbox[2]) / 2;\n        var centroid_y = (bbox[1] + bbox[3]) / 2;\n        return [centroid_x, centroid_y];\n    }\n    function calculateEuclideanDistance(centroid1, centroid2) {\n        return Math.sqrt((centroid2[0] - centroid1[0]) ** 2 + (centroid2[1] - centroid1[1]) ** 2);\n    }\n    function calculateIoU(bbox1, bbox2) {\n        var xmin1 = bbox1[0], ymin1 = bbox1[1], xmax1 = bbox1[2], ymax1 = bbox1[3];\n        var xmin2 = bbox2[0], ymin2 = bbox2[1], xmax2 = bbox2[2], ymax2 = bbox2[3];\n        var inter_xmin = Math.max(xmin1, xmin2);\n        var inter_ymin = Math.max(ymin1, ymin2);\n        var inter_xmax = Math.min(xmax1, xmax2);\n        var inter_ymax = Math.min(ymax1, ymax2);\n        var inter_width = Math.max(0, inter_xmax - inter_xmin);\n        var inter_height = Math.max(0, inter_ymax - inter_ymin);\n        var inter_area = inter_width * inter_height;\n        var bbox1_area = (xmax1 - xmin1) * (ymax1 - ymin1);\n        var bbox2_area = (xmax2 - xmin2) * (ymax2 - ymin2);\n        var iou = inter_area / (bbox1_area + bbox2_area - inter_area);\n        return iou;\n    }\n    function calculateIoR(bbox1, bbox2) {\n        var xmin1 = bbox1[0], ymin1 = bbox1[1], xmax1 = bbox1[2], ymax1 = bbox1[3];\n        var xmin2 = bbox2[0], ymin2 = bbox2[1], xmax2 = bbox2[2], ymax2 = bbox2[3];\n        var inter_xmin = Math.max(xmin1, xmin2);\n        var inter_ymin = Math.max(ymin1, ymin2);\n        var inter_xmax = Math.min(xmax1, xmax2);\n        var inter_ymax = Math.min(ymax1, ymax2);\n        var inter_width = Math.max(0, inter_xmax - inter_xmin);\n        var inter_height = Math.max(0, inter_ymax - inter_ymin);\n        var inter_area = inter_width * inter_height;\n        var bbox1_area = (xmax1 - xmin1) * (ymax1 - ymin1);\n        var bbox2_area = (xmax2 - xmin2) * (ymax2 - ymin2);\n        var ior = inter_area / (bbox1_area);\n        return ior;\n    }\n    var occupied = [];\n    var current_index = -1;\n    // initialize lots to no object\n    for (let key1 in payload[\"lots\"]) {\n        if (payload[\"lots\"].hasOwnProperty(key1)) {\n            occupied.push({\"occupied\": 0});\n        }\n    }\n    // replicating the \"smart_parking\" algorithm\n    // get object centroids\n    for (let key1 in payload[\"objects\"]) {\n        current_index++;\n        if (payload[\"objects\"].hasOwnProperty(key1)) {\n            var objectCentroid = getCentroid(payload[\"objects\"][key1]);\n            // loop through region and find the best object\n            var potential_region = [];\n            for (let key2 in payload[\"lots\"]) {\n                if (payload[\"lots\"].hasOwnProperty(key2)) {\n                    var regionCentroid = getCentroid(payload[\"lots\"][key2]);\n                    var euclideanDistance = calculateEuclideanDistance(objectCentroid, regionCentroid);\n                    potential_region.push(euclideanDistance);\n                }\n            }\n            // check all lots occupied by the object\n            if (object_counter) {\n                for (let i = 0; i < potential_region.length; i++) {\n                    if (potential_region[i] < distance_threshold) {\n                        var IoR = calculateIoR(payload[\"objects\"][key1], payload[\"lots\"][i]);\n                        if (IoR > IoU_threshold) {\n                            occupied[i][\"occupied\"] += 1;\n                            var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                            var numberData = keyData.length;\n\n                            for (let j = 0; j < numberData; j++) {\n                                if (!occupied[i][\"extra\"]) {\n                                    occupied[i][\"extra\"] = {};\n                                }\n\n                                if (!occupied[i][\"extra\"][keyData[j]]) {\n                                    occupied[i][\"extra\"][keyData[j]] = [];\n                                }\n                                occupied[i][\"extra\"][keyData[j]].push(payload[\"objects_extra\"][current_index][keyData[j]]);\n                            }\n                        }\n                    }\n                }\n            }\n            // get the best lot occupied by the object\n            else {\n                var best_region_index = potential_region.reduce((minIndex, currentValue, currentIndex, array) =>\n                    currentValue < array[minIndex] ? currentIndex : minIndex, 0);\n                if (potential_region[best_region_index] < distance_threshold) {\n                    var IoR = calculateIoR(payload[\"objects\"][key1], payload[\"lots\"][best_region_index]);\n                    if (IoR > IoU_threshold) {\n                        occupied[best_region_index][\"occupied\"] += 1;\n                        var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                        var numberData = keyData.length;\n\n                        for (let i = 0; i < numberData; i++) {\n                            if (!occupied[best_region_index][\"extra\"]) {\n                                occupied[best_region_index][\"extra\"] = {};\n                            }\n\n                            if (!occupied[best_region_index][\"extra\"][keyData[i]]) {\n                                occupied[best_region_index][\"extra\"][keyData[i]] = [];\n                            }\n                            occupied[best_region_index][\"extra\"][keyData[i]].push(payload[\"objects_extra\"][current_index][keyData[i]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return occupied\n}\n\n// turn into correct format\nfunction postprocess_output(occupied) {\n    var results = {};\n\n    for (let i = 0; i < occupied.length; i++) {\n        if (!results[\"Region \" + (i + 1)]) {\n            results[\"Region \" + (i + 1)] = {};\n        }\n\n        results[\"Region \" + (i + 1)][\"video_id\"] = video_id;\n        results[\"Region \" + (i + 1)][\"region_id\"] = (region_id != -1) ? region_id : i + 1;\n\n        if (occupied[i].hasOwnProperty('occupied')) {\n            results[\"Region \" + (i + 1)][\"occupied\"] = occupied[i].occupied;\n        }\n\n        if (occupied[i].hasOwnProperty('extra')) {\n            for (let key in occupied[i].extra) {\n                results[\"Region \" + (i + 1)][key] = occupied[i].extra[key];\n            }\n        }\n\n        results[\"Region \" + (i + 1)][\"actual_entry_time\"] = null;\n        results[\"Region \" + (i + 1)][\"entry_time\"] = null;\n        results[\"Region \" + (i + 1)][\"dwell_time\"] = null;\n        results[\"Region \" + (i + 1)][\"exit_time\"] = null;\n        results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n\n        if (!previous_data) {\n            previous_data = {};\n        }\n\n        if (!previous_data.hasOwnProperty(\"Region \" + (i + 1))) {\n            previous_data[\"Region \" + (i + 1)] = results[\"Region \" + (i + 1)];\n            previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"entry_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"dwell_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"exit_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n        }\n\n        if (results[\"Region \" + (i + 1)][\"occupied\"] > 0) {\n            if (previous_data[\"Region \" + (i + 1)][\"entry_time\"] == null) {\n                results[\"Region \" + (i + 1)][\"actual_entry_time\"] = msg.nodered_timestamp;\n                results[\"Region \" + (i + 1)][\"entry_time\"] = msg.object_timestamp;\n            }\n            else {\n                if (previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] >= occupancy_check_duration) {\n                    results[\"Region \" + (i + 1)][\"dwell_time\"] = \"00:00:00\";\n                    results[\"Region \" + (i + 1)][\"actual_entry_time\"] = msg.nodered_timestamp;\n                    results[\"Region \" + (i + 1)][\"entry_time\"] = msg.object_timestamp;\n                }\n                else {\n                    results[\"Region \" + (i + 1)][\"actual_entry_time\"] = previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"];\n                    results[\"Region \" + (i + 1)][\"entry_time\"] = previous_data[\"Region \" + (i + 1)][\"entry_time\"];\n                }\n                var dwell_timestamp = msg.object_timestamp - results[\"Region \" + (i + 1)][\"entry_time\"];\n\n                var dwell_hours = Math.floor(dwell_timestamp / 3600).toString();\n                dwell_hours = dwell_hours.toString().length == 1 ? dwell_hours.toString().padStart(2, '0') : dwell_hours.toString();\n\n                var dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, '0');\n                var dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, '0');\n\n                results[\"Region \" + (i + 1)][\"dwell_time\"] = dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds;\n                results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n            }\n        }\n        else if (previous_data[\"Region \" + (i + 1)][\"entry_time\"]) {\n            results[\"Region \" + (i + 1)][\"actual_entry_time\"] = previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"];\n            results[\"Region \" + (i + 1)][\"entry_time\"] = previous_data[\"Region \" + (i + 1)][\"entry_time\"];\n            results[\"Region \" + (i + 1)][\"dwell_time\"] = previous_data[\"Region \" + (i + 1)][\"dwell_time\"];\n            results[\"Region \" + (i + 1)][\"occupancy_check\"] = previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] + 1;\n\n            if (previous_data[\"Region \" + (i + 1)][\"exit_time\"]) {\n                results[\"Region \" + (i + 1)][\"exit_time\"] = previous_data[\"Region \" + (i + 1)][\"exit_time\"];\n            }\n            else {\n                results[\"Region \" + (i + 1)][\"exit_time\"] = msg.nodered_timestamp;\n            }\n        }\n    }\n    return results;\n}\n\nfunction main(payload, distance_threshold = 100, IoU_threshold = 0.5, object_counter = false) {\n    var results = preprocess_bboxes(payload);\n    var occupied = euclidean_iou_function(results, distance_threshold, IoU_threshold, object_counter);\n    var out = postprocess_output(occupied);\n    flow.set(previous_data_name, out);\n    return out;\n}\n\n// user-defined parameters\nvar distance_threshold = flow.get('distance_threshold');\nvar ior_threshold = flow.get('ior_threshold');\nvar object_counter = flow.get('object_counter');\n\nmsg.payload = main(payload, distance_threshold, ior_threshold, object_counter);\nflow.set(detection_name, msg);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 980,
        "wires": [
            [
                "5b7c5c77f12dd746"
            ]
        ]
    },
    {
        "id": "1380acd8df733731",
        "type": "euclidean and ior",
        "z": "2720733497fe05f3",
        "name": "euclidean and ior 4",
        "func": "let region_name = 'predefined_regions_4';\nlet detection_name = 'object_detection_4';\nlet previous_data_name = 'previous_data_4';\nlet occupancy_check_duration = 60;\nlet video_id = 4;\nlet region_id = -1; //Recommend to set this only when there is 1 predefined region in the video\n\nvar payload = msg.payload;\nvar previous_data = flow.get(previous_data_name);\n\n// preparing bboxes\nfunction preprocess_bboxes(payload) {\n    function getObjectData(object_data) {\n        var current_object_data = {};\n        if (object_data.hasOwnProperty('type')) {\n            current_object_data[\"type\"] = object_data['type'];\n        }\n        if (object_data.hasOwnProperty('color')) {\n            current_object_data[\"color\"] = object_data['color'];\n        }\n        if (object_data.hasOwnProperty('license_plate')) {\n            current_object_data[\"license_plate\"] = object_data['license_plate'];\n        }\n        if (object_data.hasOwnProperty('id')) {\n            current_object_data[\"id\"] = object_data['id'];\n        }\n        if (object_data.hasOwnProperty('roi_type')) {\n            current_object_data[\"roi_type\"] = object_data['roi_type'];\n        }\n        if (object_data.hasOwnProperty('loiter_possibility')) {\n            if (object_data['loiter_possibility'] == false) {\n                return null\n            }\n        }\n        return current_object_data;\n    }\n    function getObjectBbox(object_data) {\n        return [object_data.xmin, object_data.ymin, object_data.xmax, object_data.ymax];\n    }\n    function getLotBbox(lot_data) {\n        return [lot_data.xmin, lot_data.ymin, lot_data.xmax, lot_data.ymax];\n    }\n\n    var results = {};\n    var objects = [];\n    var objects_extra = [];\n    var lots = [];\n\n    // get all objects bboxes\n    for (let key in payload) {\n        if (payload.hasOwnProperty(key)) {\n            var getObject = getObjectData(payload[key]);\n            if (getObject !== null) {\n                objects_extra.push(\n                    getObject\n                )\n                objects.push(\n                    getObjectBbox(payload[key])\n                );\n            }\n        }\n    }\n\n    // get all lots bboxes\n    var predefined_regions = flow.get(region_name);\n    var keys = Object.keys(predefined_regions);\n\n    for (let i = 0; i < keys.length; i++) {\n        if (predefined_regions.hasOwnProperty(keys[i]) && keys[i] != \"_msgid\") {\n            lots.push(\n                getLotBbox(predefined_regions[keys[i]])\n            );\n        }\n    }\n\n    results[\"objects\"] = objects;\n    results[\"objects_extra\"] = objects_extra;\n    results[\"lots\"] = lots;\n    return results;\n}\n\n// euclidean distance and iou check\nfunction euclidean_iou_function(payload, distance_threshold = 100, IoU_threshold = 0.5, object_counter = false) {\n    function getCentroid(bbox) {\n        var centroid_x = (bbox[0] + bbox[2]) / 2;\n        var centroid_y = (bbox[1] + bbox[3]) / 2;\n        return [centroid_x, centroid_y];\n    }\n    function calculateEuclideanDistance(centroid1, centroid2) {\n        return Math.sqrt((centroid2[0] - centroid1[0]) ** 2 + (centroid2[1] - centroid1[1]) ** 2);\n    }\n    function calculateIoU(bbox1, bbox2) {\n        var xmin1 = bbox1[0], ymin1 = bbox1[1], xmax1 = bbox1[2], ymax1 = bbox1[3];\n        var xmin2 = bbox2[0], ymin2 = bbox2[1], xmax2 = bbox2[2], ymax2 = bbox2[3];\n        var inter_xmin = Math.max(xmin1, xmin2);\n        var inter_ymin = Math.max(ymin1, ymin2);\n        var inter_xmax = Math.min(xmax1, xmax2);\n        var inter_ymax = Math.min(ymax1, ymax2);\n        var inter_width = Math.max(0, inter_xmax - inter_xmin);\n        var inter_height = Math.max(0, inter_ymax - inter_ymin);\n        var inter_area = inter_width * inter_height;\n        var bbox1_area = (xmax1 - xmin1) * (ymax1 - ymin1);\n        var bbox2_area = (xmax2 - xmin2) * (ymax2 - ymin2);\n        var iou = inter_area / (bbox1_area + bbox2_area - inter_area);\n        return iou;\n    }\n    function calculateIoR(bbox1, bbox2) {\n        var xmin1 = bbox1[0], ymin1 = bbox1[1], xmax1 = bbox1[2], ymax1 = bbox1[3];\n        var xmin2 = bbox2[0], ymin2 = bbox2[1], xmax2 = bbox2[2], ymax2 = bbox2[3];\n        var inter_xmin = Math.max(xmin1, xmin2);\n        var inter_ymin = Math.max(ymin1, ymin2);\n        var inter_xmax = Math.min(xmax1, xmax2);\n        var inter_ymax = Math.min(ymax1, ymax2);\n        var inter_width = Math.max(0, inter_xmax - inter_xmin);\n        var inter_height = Math.max(0, inter_ymax - inter_ymin);\n        var inter_area = inter_width * inter_height;\n        var bbox1_area = (xmax1 - xmin1) * (ymax1 - ymin1);\n        var bbox2_area = (xmax2 - xmin2) * (ymax2 - ymin2);\n        var ior = inter_area / (bbox1_area);\n        return ior;\n    }\n    var occupied = [];\n    var current_index = -1;\n    // initialize lots to no object\n    for (let key1 in payload[\"lots\"]) {\n        if (payload[\"lots\"].hasOwnProperty(key1)) {\n            occupied.push({\"occupied\": 0});\n        }\n    }\n    // replicating the \"smart_parking\" algorithm\n    // get object centroids\n    for (let key1 in payload[\"objects\"]) {\n        current_index++;\n        if (payload[\"objects\"].hasOwnProperty(key1)) {\n            var objectCentroid = getCentroid(payload[\"objects\"][key1]);\n            // loop through region and find the best object\n            var potential_region = [];\n            for (let key2 in payload[\"lots\"]) {\n                if (payload[\"lots\"].hasOwnProperty(key2)) {\n                    var regionCentroid = getCentroid(payload[\"lots\"][key2]);\n                    var euclideanDistance = calculateEuclideanDistance(objectCentroid, regionCentroid);\n                    potential_region.push(euclideanDistance);\n                }\n            }\n            // check all lots occupied by the object\n            if (object_counter) {\n                for (let i = 0; i < potential_region.length; i++) {\n                    if (potential_region[i] < distance_threshold) {\n                        var IoR = calculateIoR(payload[\"objects\"][key1], payload[\"lots\"][i]);\n                        if (IoR > IoU_threshold) {\n                            occupied[i][\"occupied\"] += 1;\n                            var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                            var numberData = keyData.length;\n\n                            for (let j = 0; j < numberData; j++) {\n                                if (!occupied[i][\"extra\"]) {\n                                    occupied[i][\"extra\"] = {};\n                                }\n\n                                if (!occupied[i][\"extra\"][keyData[j]]) {\n                                    occupied[i][\"extra\"][keyData[j]] = [];\n                                }\n                                occupied[i][\"extra\"][keyData[j]].push(payload[\"objects_extra\"][current_index][keyData[j]]);\n                            }\n                        }\n                    }\n                }\n            }\n            // get the best lot occupied by the object\n            else {\n                var best_region_index = potential_region.reduce((minIndex, currentValue, currentIndex, array) =>\n                    currentValue < array[minIndex] ? currentIndex : minIndex, 0);\n                if (potential_region[best_region_index] < distance_threshold) {\n                    var IoR = calculateIoR(payload[\"objects\"][key1], payload[\"lots\"][best_region_index]);\n                    if (IoR > IoU_threshold) {\n                        occupied[best_region_index][\"occupied\"] += 1;\n                        var keyData = Object.keys(payload[\"objects_extra\"][current_index]);\n                        var numberData = keyData.length;\n\n                        for (let i = 0; i < numberData; i++) {\n                            if (!occupied[best_region_index][\"extra\"]) {\n                                occupied[best_region_index][\"extra\"] = {};\n                            }\n\n                            if (!occupied[best_region_index][\"extra\"][keyData[i]]) {\n                                occupied[best_region_index][\"extra\"][keyData[i]] = [];\n                            }\n                            occupied[best_region_index][\"extra\"][keyData[i]].push(payload[\"objects_extra\"][current_index][keyData[i]]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return occupied\n}\n\n// turn into correct format\nfunction postprocess_output(occupied) {\n    var results = {};\n\n    for (let i = 0; i < occupied.length; i++) {\n        if (!results[\"Region \" + (i + 1)]) {\n            results[\"Region \" + (i + 1)] = {};\n        }\n\n        results[\"Region \" + (i + 1)][\"video_id\"] = video_id;\n        results[\"Region \" + (i + 1)][\"region_id\"] = (region_id != -1) ? region_id : i + 1;\n\n        if (occupied[i].hasOwnProperty('occupied')) {\n            results[\"Region \" + (i + 1)][\"occupied\"] = occupied[i].occupied;\n        }\n\n        if (occupied[i].hasOwnProperty('extra')) {\n            for (let key in occupied[i].extra) {\n                results[\"Region \" + (i + 1)][key] = occupied[i].extra[key];\n            }\n        }\n\n        results[\"Region \" + (i + 1)][\"actual_entry_time\"] = null;\n        results[\"Region \" + (i + 1)][\"entry_time\"] = null;\n        results[\"Region \" + (i + 1)][\"dwell_time\"] = null;\n        results[\"Region \" + (i + 1)][\"exit_time\"] = null;\n        results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n\n        if (!previous_data) {\n            previous_data = {};\n        }\n\n        if (!previous_data.hasOwnProperty(\"Region \" + (i + 1))) {\n            previous_data[\"Region \" + (i + 1)] = results[\"Region \" + (i + 1)];\n            previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"entry_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"dwell_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"exit_time\"] = null;\n            previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n        }\n\n        if (results[\"Region \" + (i + 1)][\"occupied\"] > 0) {\n            if (previous_data[\"Region \" + (i + 1)][\"entry_time\"] == null) {\n                results[\"Region \" + (i + 1)][\"actual_entry_time\"] = msg.nodered_timestamp;\n                results[\"Region \" + (i + 1)][\"entry_time\"] = msg.object_timestamp;\n            }\n            else {\n                if (previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] >= occupancy_check_duration) {\n                    results[\"Region \" + (i + 1)][\"dwell_time\"] = \"00:00:00\";\n                    results[\"Region \" + (i + 1)][\"actual_entry_time\"] = msg.nodered_timestamp;\n                    results[\"Region \" + (i + 1)][\"entry_time\"] = msg.object_timestamp;\n                }\n                else {\n                    results[\"Region \" + (i + 1)][\"actual_entry_time\"] = previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"];\n                    results[\"Region \" + (i + 1)][\"entry_time\"] = previous_data[\"Region \" + (i + 1)][\"entry_time\"];\n                }\n                var dwell_timestamp = msg.object_timestamp - results[\"Region \" + (i + 1)][\"entry_time\"];\n\n                var dwell_hours = Math.floor(dwell_timestamp / 3600).toString();\n                dwell_hours = dwell_hours.toString().length == 1 ? dwell_hours.toString().padStart(2, '0') : dwell_hours.toString();\n\n                var dwell_mins = Math.floor((dwell_timestamp / 60) % 60).toString().padStart(2, '0');\n                var dwell_seconds = Math.floor(dwell_timestamp % 60).toString().padStart(2, '0');\n\n                results[\"Region \" + (i + 1)][\"dwell_time\"] = dwell_hours + \":\" + dwell_mins + \":\" + dwell_seconds;\n                results[\"Region \" + (i + 1)][\"occupancy_check\"] = 0;\n            }\n        }\n        else if (previous_data[\"Region \" + (i + 1)][\"entry_time\"]) {\n            results[\"Region \" + (i + 1)][\"actual_entry_time\"] = previous_data[\"Region \" + (i + 1)][\"actual_entry_time\"];\n            results[\"Region \" + (i + 1)][\"entry_time\"] = previous_data[\"Region \" + (i + 1)][\"entry_time\"];\n            results[\"Region \" + (i + 1)][\"dwell_time\"] = previous_data[\"Region \" + (i + 1)][\"dwell_time\"];\n            results[\"Region \" + (i + 1)][\"occupancy_check\"] = previous_data[\"Region \" + (i + 1)][\"occupancy_check\"] + 1;\n\n            if (previous_data[\"Region \" + (i + 1)][\"exit_time\"]) {\n                results[\"Region \" + (i + 1)][\"exit_time\"] = previous_data[\"Region \" + (i + 1)][\"exit_time\"];\n            }\n            else {\n                results[\"Region \" + (i + 1)][\"exit_time\"] = msg.nodered_timestamp;\n            }\n        }\n    }\n    return results;\n}\n\nfunction main(payload, distance_threshold = 100, IoU_threshold = 0.5, object_counter = false) {\n    var results = preprocess_bboxes(payload);\n    var occupied = euclidean_iou_function(results, distance_threshold, IoU_threshold, object_counter);\n    var out = postprocess_output(occupied);\n    flow.set(previous_data_name, out);\n    return out;\n}\n\n// user-defined parameters\nvar distance_threshold = flow.get('distance_threshold');\nvar ior_threshold = flow.get('ior_threshold');\nvar object_counter = flow.get('object_counter');\n\nmsg.payload = main(payload, distance_threshold, ior_threshold, object_counter);\nflow.set(detection_name, msg);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 1100,
        "wires": [
            [
                "5b7c5c77f12dd746"
            ]
        ]
    },
    {
        "id": "24121c3bf9a2dc3a",
        "type": "data table output",
        "z": "2720733497fe05f3",
        "name": "data table output 1",
        "func": "var header = [\"Zone ID\", \"Spot ID\", \"Status\", \"Type\", \"Color\", \"Entry Time\", \"Dwell Time\"];\nvar data = [\"video_id\", \"region_id\", \"occupied\", \"roi_type\", \"color\", \"actual_entry_time\", \"dwell_time\"];\n\nvar result = { \"payload\": {} };\nvar payload = msg.payload;\nvar keys = Object.keys(payload);\n\nif (keys.length == 0) {\n    return result;\n}\n\nvar offset = 0;\n\nfor (let i = 0; i < keys.length; i++) {\n    var num_data = 1;\n\n    for (let h = 0; h < data.length; h++) {\n        var data_value = payload[keys[i]][data[h]];\n        if (Array.isArray(data_value) && data_value.length > num_data) {\n            num_data = data_value.length;\n        }\n    }\n\n    for (let h = 0; h < num_data; h++) {\n\n        if (h > 0) {\n            offset += 1;\n        }\n\n        result.payload[\"Region \" + (i + 1 + offset)] = {};\n\n        for (let g = 0; g < data.length; g++) {\n            var data_value = payload[keys[i]][data[g]];\n\n            if (data[g] == \"occupied\") {\n                if (data_value == 0) {\n                    result.payload[\"Region \" + (i + 1 + offset)][header[g]] = \"Empty\";\n                }\n                else {\n                    result.payload[\"Region \" + (i + 1 + offset)][header[g]] = \"Occupied\";\n                }\n            }\n            else {\n                if (Array.isArray(data_value)) {\n                    data_value = data_value[h];\n                }\n                result.payload[\"Region \" + (i + 1 + offset)][header[g]] = data_value;\n            }\n        }\n    }\n}\nreturn result;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1150,
        "y": 900,
        "wires": [
            [
                "736d3038190617d8"
            ]
        ]
    },
    {
        "id": "efc1d3e922603b9f",
        "type": "debug",
        "z": "2720733497fe05f3",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 620,
        "wires": []
    }
]